[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "Marc Thévenin",
    "section": "",
    "text": "Sms-Ined\n\n\n\n\n\n\nLiens Ined\n\n\n\n\nSite de l’Ined: \nSite du Service Méthodes Statistiques: \n\nSite des Rencontres de Statistique Appliquée: \n\nSite du séminaire R à l’Usage des Sciences Sociales (RUSS): \n\n\n\n\n\n\n\n\n\nAutres supports\n\n\n\n\nFormation analyse des durées (2017-2020): https://mthevenin.github.io/analyse_duree/\nFormation introduction à Stata (2018): datée - mise à jour en cours"
  },
  {
    "objectID": "bases/Readme.html",
    "href": "bases/Readme.html",
    "title": "",
    "section": "",
    "text": "rbnb_paris\n\npingouin"
  },
  {
    "objectID": "bases/Readme.html#rbnb_paris.dta",
    "href": "bases/Readme.html#rbnb_paris.dta",
    "title": "",
    "section": "2.1 rbnb_paris.dta",
    "text": "2.1 rbnb_paris.dta\nContains data from rbnb_paris.dta\n Observations:        56,914                  \n    Variables:             3                  11 Jul 2022 12:46\n-------------------------------------------------------------------\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n-------------------------------------------------------------------\nzone            long    %19.0g     zone       \ntype            float   %15.0g     type       \n-------------------------------------------------------------------\n     +------------------------------------------+\n     | price                  zone         type |\n     |------------------------------------------|\n  1. |     .                     .       autres |\n  2. |    59       Buttes-Chaumont   apt/maison |\n  3. |    30               Reuilly   apt/maison |\n  4. |    53          Ménilmontant   apt/maison |\n  5. |   500   Batignolles-Monceau   apt/maison |\n     +------------------------------------------+\nOuverture:\nwebuse set https://github.com/mthevenin/stata_graphiques/tree/main/bases\nuse rbnb_paris, replace\nwebuse set"
  },
  {
    "objectID": "bases/Readme.html#pingouins.dta",
    "href": "bases/Readme.html#pingouins.dta",
    "title": "",
    "section": "2.2 pingouins.dta",
    "text": "2.2 pingouins.dta\n------------------------------------------------------------------------------------------\nVariable      Storage   Display    Value\n    name         type    format    label      Variable label\n------------------------------------------------------------------------------------------\nspecies         str9    %9s                   species\nisland          str9    %9s                   island\nbill_length_mm  double  %10.0g                bill_length_mm\nbill_depth_mm   double  %10.0g                bill_depth_mm\nflipper_lengt~m int     %10.0g                flipper_length_mm\nbody_mass_g     int     %10.0g                body_mass_g\nsex             str6    %9s                   sex\nyear            int     %10.0g                year\nespèce          long    %9.0g      espèce     species\n------------------------------------------------------------------------------------------\n\n     +------------------------------------------------------------------------------------------+\n     | species      island   bill_l~m   bill_d~m   flippe~m   body_m~g      sex   year   espèce |\n     |------------------------------------------------------------------------------------------|\n  1. |  Adelie   Torgersen       39.1       18.7        181       3750     male   2007   Adelie |\n  2. |  Adelie   Torgersen       39.5       17.4        186       3800   female   2007   Adelie |\n  3. |  Adelie   Torgersen       40.3         18        195       3250   female   2007   Adelie |\n  4. |  Adelie   Torgersen          .          .          .          .            2007   Adelie |\n  5. |  Adelie   Torgersen       36.7       19.3        193       3450   female   2007   Adelie |\n     +------------------------------------------------------------------------------------------+\nOuverture:\nwebuse set https://github.com/mthevenin/stata_graphiques/tree/main/bases\nuse pingouin, replace\nwebuse set"
  },
  {
    "objectID": "formation/formation.html",
    "href": "formation/formation.html",
    "title": "Introduction",
    "section": "",
    "text": "todo\n\n\n\n\n\n\nProchaines mises à jour\n\n\n\n\nIntroduction/présentation - remerciements [à faire]\nLiens externes principaux [à faire]\nChapitre 4: visualisation des données avec Stata\n\npas satisfait de l’organisation du chapitre, bien que classique… j’y réfléchis\nvoir déjà en page d’acceuil les solutions très nettement améliorée avec par exemple fabplot\n\nChapitre 5: principalement réservé à l’exécution de graphique avec Python, principalement avec seaborn et plotnine, ainsi que quelques graphiques intéractifs avec plotly [MAJ EN COURS]\n\n\n\nLes programmes des chapitres sont disponibles aux adresses suivantes:\n\nChapitre 1: https://github.com/mthevenin/stata_graphiques/blob/main/programmes/chapitre1.do\nChapitre 2: https://github.com/mthevenin/stata_graphiques/blob/main/programmes/chapitre2.do\n\n\nINTRODUCTION A LA SEMIOLOGIE GRAPHIQUE (Bénédicte Garnier - Ined-SMS)\nLien vers le document:"
  },
  {
    "objectID": "formation/formation11.html",
    "href": "formation/formation11.html",
    "title": "Types et syntaxe",
    "section": "",
    "text": "On peut identifier deux types de graphiques avec Stata.\n\n\n\nLes graphiques de type one-way : coordonnées sur un seul axe avec ou non, un axe discret. Ils peuvent être préfixés ou non par graph: graph box, graph bar, histogram …..\n\nLes graphiques de type two-way : coordonnées sur deux axes, optionnellement selon le type de graphique un troisième axe peut être renseigné. Ils sont préfixés ou non par tw (twoway) : tw scatter, tw line, …\n\nCertains types de graphiques sont de type oneway ou twoway. C’est le cas des histogrammes avec une commande histogram et une commande tw histogram.\n Les coordonnées sont généralement renseignées par des noms de variables. Pour certaines commandes graphiques, les valeurs sont directement renseignées: tw scatteri pour un nuage ou tw pci pour des segments [ici 4 coordonnées : (ymin, xmin) et (ymax, xmax)].\nUn graphique peut être aussi généré par une fonction : tw function y = f(x).\nOn peut obtenir la liste et aides des commandes graphiques officielles avec help graph.\n\n\n\nUn graphique peut devenir assez gourmand en options. Par défaut avec Stata l’exécution est faite ligne par ligne avec l’option par défaut #delimit cr. Pour exécuter une commande sur plusieurs lignes, il est d’usage d’utiliser un triple slash ///. Pour les graphiques, cette option manque de souplesse et peut provoquer des messages d’erreur lorsque /// est attaché par inadvertance au dernier caractère d’une ligne.\nLorsque le nombre de lignes devient assez conséquent, il est préférable d’utiliser ; comme délimiteur. Le changement de délimiteur se fait avec #delimit ; et on indique la fin de l’exécution avec ;. On retourne au délimiteur par défaut avec #delimit cr.\n\n#delimit ;\ntw scatter y x,\n[option1]\n[option2]\n[option3]\n.\n.\n[option n]\n;\n\n#delimit cr\n* Suite du programm\n\n\n\n\nPour des raisons de vocabulaire, nous allons utiliser le terme de géométrie utilisée par l’incontournable librairie ggplot2 de R pour identifier un type de graphique comme scatter, line…. Mais pas seulement. en fin de document je traite de l’utilisation de la librairie Python plotnine, qui est un wrapper relativement complet de ggplot2, directement exécutable dans un éditeur .do ou .ado. depuis la version 16 de Stata.\nEn première approche, la syntaxe d’un graphique avec Stata est particulièrement simple :\n\n[tw/graph] type_géométrie coordonnées [if/in] [weight], [options géométrie] [,[options du graphique]]\n\n\n\n\nUn graphique comportant plusieurs géométries de même type peut être exécuté avec un seul bloc de coordonnées renseigné par des variables pour l’axe des ordonnées. Ces différentes coordonnées peuvent être des variables correspondant à plusieurs valeurs d’une variable additionnelle, souvent de type catégoriel [voir la commande separate plus bas].\n\n[tw/graph] type_géométrie Y1 Y2 Y3.... [X] [, option1(Y1 Y2 Y3...)..options_du graphique]\n\nLes options de la géométrie (plusieurs coordonnées pour Y) comme les couleurs ou les tailles/épaisseurs sont indiquées à la suite dans l’option choisie. Si on veut changer les couleurs de plusieurs courbes associées aux variable y1,y2 et y3: color(couleurY1 couleurY2 couleurY3).\nExemple\nGraphique de type line, reportant les espérances de vie aux USA de 1900 à 2000. Le premier graphique est sans option, le second en comporte.\n\nPremier graphique (haut)\n\nsysuse lifeexp, clear\ntw line le_male le_female year \n\nSecond graphique (bas)\n\nsysuse lifeexp, clear\n\n#delimit ;\ntw line  le_male le_female year, \n                                         \n  lc(*.8 *1.2)                                                        \n  lw(*4 *4)\n                                                               \n  title(\"Espérance de vie aux USA\", pos(11))                                  \n  legend(order(1 \"Hommes\" 2 \"Femmes\") pos(4) col(1) ring(0))             \n  ylabel(35(5)80, angle(0))  \n  xtitle(\"Année\")   \n  graphr(color(white)) plotr(color(white))\n;\n\n\n\n\n\n\n\nNote\n\n\n\n Avec le changement de délimiteur, il est plus facile de distinguer les différents éléments du graphique, comme les options qui affectent directement les courbes (couleur, épaisseur) et les options générales du graphique (titre, légende, labels de y à l’horizontal, titre de x, couleur de fond).\n\n\nOptions des courbes:\n\nlc(...): je baisse la saturation de la courbe des hommes de 20% (plus claire) et j’augmente celle des femmes de 20% (plus foncée). Les couleurs par défaut sont conservées (palette Stata s2color).\nlw(...): j’augmente fortement l’épaisseur des courbes (*4). Stata dispose de plusieurs unités pour altérer les tailles et épaisseurs, celle utilisée par défaut est une unité de type relative (voir la section dédiées plus bas).\n\nOptions du graphique:\n\nJ’ajoute un titre avec l’option title(…) que je positionne à 11 heures à l’extérieur avec l’argument pos(11).\nJe change les labels de la légende dans l’option legend(...) avec l’argument order(...). Je change la position de la légende en a mettant dans la zône du graphique avec ring(0) et à 4 heures avec pos(4). Les labels sont reportés sur une colonne avec l’argument col(1).\nJe modifie les labels des ordonnées avec l’option ylabel(...), en changeant le delta des coordonnées reportées et en mettant les labels à l’horizontal avec l’argument angle(0).\nJe modifie le titre des abscisses avec l’option xtitle(...).\nJe modifie les couleurs de fonds du graphique qui est composée de deux zônes: la zône où est réellement tracé le graphique avec l’option plotr() [ou plotregion(...)] et la zône externe avec graphr(...) [ou graphregion(...)] où se trouve reporté par défaut les titres et les légendes. Pour changer la couleur de fond, on utilise l’argument color(...).\n\n\n\n\nDans l’exemple précédent on avait deux variables, mais il est plus standard que les bases donnent des observations à partir d’une variable qui peut être croisées avec d’autres informations regroupées avec une variable discrète. Par rapport à d’autres langages graphiques, on pense bien évidemment à R avec ggplot, les choses se gâtent un peu du côté de Stata car plusieurs graphiques doivent être exécutés séparément dans la même commande. On donnera plus loin un moyen via les macros et les boucles d’automatiser cette exécution. Cela ne concerne que les éléments surperposés, Stata possédant en revanche une option pour générer des sous graphiques de type facettes ou small-multiple (voir section sur les graphiques combinés).\nChaque sous graphique a son propre jeu d’options et ont doit bien indiquer leur séparation, soit avec des parenthèses soit avec des doubles barres horizontales.\n\n(graph 1, options graph1) (graph2, options graph2)… (graph n, option graph n) , options graphiques\n\nou\n\ngraph 1, options graph1 || graph2, options graph2 ||…. || graph n, option graph n || , options graphiques\n\nMa préférence va plutôt à la deuxième solution pour éviter une surabondance de parenthèses déjà très présentes, et souvent imbriquées dans les options. Par ailleurs il me semble qu’on visualise mieux la séparation entre les différents éléments graphiques.\nPrincipe de la syntaxe avec ; comme délimiteur\nGraphiques séparés par ()\n\n#delimit ;\n[tw/graph] \n(type_géométrie1 Y1 [X1] [Y2] [X2] [Z] [in if] [weight]\n[, options(1)]) \n  \n(type_géométrie2 Y2 [X1] [Y2] [X2] [Z] [in if] [weight]\n[, options(2)])\n...)\n                                    \n[, options_graphiques] \n; \n\nGraphiques séparés par ||\n\n#delimit ;\n[tw/graph] \n   type_géométrie1 Y1 [X1] [Y2] [X2] [Z] [in if] [weight]\n[, options(1)] \n  \n|| type_géométrie2 Y2 [X1] [Y2] [X2] [Z] [in if] [weight]\n[, options(2)]) \n\n...                                    \n|| [, options_graphiques] \n;  \n\nExemple\nComme dans le premier graphique, celui du haut est sans option et celui du bas avec. On va afficher un nuage de point avec la base auto, entre les variables price et mpg (consommation d’essence en gallon) selon l’origine de la voiture (US ou autres pays).\n\nPremier graphique\n\nsysuse auto, clear\n\n#delimit\ntw \n    scatter price mpg if !foreign\n||  scatter price mpg if  foreign\n\n||, legend(order(1 \"US\" 2 \"Autres\"))\n;\n\n\n\n\n\n\n\nNote\n\n\n\n\nLorsqu’on superpose les sous graphiques de cette manière, Stata ne reconnait pas par défaut les labels à affecter à la légende, et affiche deux fois le label price pour chaque origine. On doit renseigner manuellement cette information.\nPetite astuce pas forcément connue de toutes et tous. Lorsqu’une variable est de type indicatrice {0,1} il n’est pas nécessaire de préciser sa valeur:\n\n!foreign est identique à foreign==0\nforeign est identique à foreign==1\n\n\n\n\nSecond graphique\n\n#delimit ;\ntw \n   scatter price mpg if !foreign, \n   mc(\"31 161 135%60\") msize(*1.5) mlc(black) mlw(.3) jitter(1)\n|| scatter price mpg if foreign, \n   mc(\"207 225 28%60\") msize(*1.5) mlc(black) mlw(.3) jitter(1) \n\n||, title(\"{bf: Prix et consommation selon l'origine}\", pos(11))   \n    legend(order(1 \"US\" 2 \"Autres\"))\n    ylabel(5000 “5k” 10000 “10k” 15000 “15k”, angle(0)) \n    xtitle(\"Consommation (miles par gallon)\") \n    ytitle(\"Prix\")\n    graphr(color(white)) plotr(color(white))\n;\n\nOptions des nuages\n\nmc(...) modifie la couleur des bulles. On verra par la suite plus en détail les altérations des couleurs, mais ici on a manuellement changé leur couleur avec un code RGB sur lequel on a réduit l’opacité à 60% (ou mis 40% de transparence).\nmlc(...) modifie la couleur du contour des bulles, ici en noir. Par défaut la couleur du contour est identique à la couleur de remplissage de la bulle.\nmsize() modifie la taille de la bulle.\nmlw() modifie l’épaisseur du contour de la bulle.\njitter() : très à la mode, les jitters sont des nuages dont les coordonnées ont été perturbées aléatoirement pour réduire les effets de superposition, ici liés à la variable mpg. A utiliser avec prudence, et éviter de trop modifier les coordonnées lorsque les coordonnées représentent des valeurs continues.\n\nOptions du graphique\n\nLe titre a été mis en gras avec une balise SMCL (Stata Markup Control Langage) : \"{bf :texte}\".\nLes valeurs des prix reportés sur l’axe des ordonnées à été modifié manuellement avec des unités k (1k = 1000).\nLe reste des options sont de même nature que celles relative au graphique précédent sur les espérances de vie."
  },
  {
    "objectID": "formation/formation12.html",
    "href": "formation/formation12.html",
    "title": "Options: couleur, épaisseur",
    "section": "",
    "text": "Il s’agit ici d’un tour d’horizon forcément incomplet des options qui vont permettre de modifier et d’habiller les graphiques, afin d’en améliorer la visibilité. On va regarder principalement les options liées aux couleurs, tailles/épaisseurs dans cette section; ainsi que quelques paramètres de bases pour les axes, légendes, titres. L’idée est de ne traiter que des options qui sont utilisées au moins une fois dans le document.\n\n\n\n\n\n\nNote\n\n\n\nUn très bon cheatsheet:\n* https://geocenter.github.io/StataTraining/pdf/StataCheatSheet_visualization15_Syntax_2016_June-REV.pdf * https://geocenter.github.io/StataTraining/pdf/StataCheatSheet_visualization15_Plots_2016_June-REV.pdf\n\n\n\n1 Couleurs\nSe reporter au chapitre 3, pour un tour d’horizon plus complet sur les couleurs et les palettes de couleurs [mettre lien]\n3 Eléments entrent dans les options relatives aux couleurs.\nNom - code couleur Un nom de couleur prédéfini ou un code couleur numérique : la couleur navy (première couleur de la palette Stata s2) a pour code RGB [Red-Green-Blue] \"26 71 11\".\nPour un élément de type ligne, courbe… : lc(navy) = lc(\"26 71 11\")\nSaturation/intensité On peut modifier la saturation : clair (blanc) <=> foncé (noir). Une couleur par défaut ou renseignée manuellement a une intensité de 1. On tire vers le blanc en réduisant cette saturation, vers le noir en l’augmentant. Après le nom ou le code couleur, l’intensité est modifiée par *# avec # supérieur ou égal à 0 (0=blanc).\nPour un élément de type barre, l’option pour modifier une couleur est donnée par fc() (f pour fill, c pour color tronqué) : fc(*.5) réduit la saturation de 50% de la couleur par défaut, fc(\"26 71 11*1.2\") augmente de 20% la saturation de la couleur navy, ici renseignée par son code RGB.\nTransparence En retard sur ce point jusqu’à la version 15 de Stata, on peut maintenant modifier l’opacité (transparence) des couleurs. La transparence permet de gérer les effets de superposition, mais on doit se méfier des effets de flou qui peuvent se révéler assez désagréable, en particulier pour les nuages en l’absence de contour sur les bulles. L’argument de l’option exprime un pourcentage d’opacité avec comme valeur minimale 0 et une valeur maximale 100 (100 = valeur par défaut). Après le nom ou le code de la couleur, l’opacité est réduite par %#. On peut utiliser une transparence totale (%0) pour cacher des éléments d’un graphique.\nPour un élément de type bulle : mc(%50) réduit de moitié l’opacité de la couleur par défaut, mc(\"26 71 11%70\") applique 70% de transparence à la couleur navy.\nComme on le voit dans le second graphique ci-dessous, il n’y a pas trop de sens à baisser simultanément la saturation et l’opacité, une couleur plus transparente étant plus claire. On peut à l’inverse augmenter la saturation et baisser l’opacité.\n\n\n\n\n\n2 Tailles/épaisseurs\nOn peut altérer les tailles et épaisseurs d’éléments composants le graphiques en s’appuyant soit sur des arguments prédéfinis, soit en jouant sur les valeurs de plusieurs types d’unités, absolues (cm, point, pouce) ou relatives. Certaines ont été implémentées à la version 16 de Stata. Lorsqu’elles sont prédéfinies, leur mémorisation peut s’avérer un peu laborieuse avec une liste qui diffère selon le type d’objet. On peut donc privilégier la modification directe des valeurs en choissisant des unités absolues (pouces, cm) ou relative. Dans mes graphiques, je priviliégie sauf exception l’utilisation de valeurs relatives.\nTailles prédéfinies\n\n \n \nTailles reposant sur des valeurs\nPour modifier directement les valeurs des tailles et épaisseurs Stata propose 6 unités : 3 absolues et 3 relatives. Ces dernières sont un peu obscures au niveau de la définition de la valeur de référence. # donne la valeur de la modification.\nAbsolues (par ordre décroissant) : le pouce (#in), le centimètre (#cm), et le point (#pt).\n Relatives:\n\noption(#rs): valeur relative par rapport au minimum de la longueur et de la largeur du graphique (=100). Si option(.5rs) et que le graphique fait 10 de largeur et 20 de longueur, la référence est associée à la largeur et est égale à 100. La taille ou l’épaisseur de l’élément fera alors .5% de cette référence. L’aide de Stata ne s’attarde pas sur ce type de modification, pas forcément très claire.\noption(#) : également une valeur par rapport au minimum de la largeur et de la longueur, mais on garde cette valeur comme référence. Avec option(.5) et que le minimum est toujours égal à 10 (largeur), la taille ou l’épaisseur de l’élément est égale à .5% de 10.\noption(*#) : coefficient multiplicateur d’une taille ou épaisseur par défaut définie par le style (thème) du graphique. Je privilégie ce type de paramétrisation. Sauf exception, j’utilise cette option.\n\n\n\n\n3 Exercice\nReproduire les deux graphiques ci-dessous avec la base auto: sysuse auto.dta.\nSolution : https://github.com/mthevenin/stata_fr/blob/master/exercices/exo1\n\nGraphique(s) 1\n\nReproduire l’un et/ou l’autre de ces graphiques avec les variables mpg et foreign.\nLes histogrammes sont générés avec la fonction tw histogram (à préférer à la commande de type oneway histogram).\nLes densités sont estimées avec la fonction kdensity [help kdensity] et le graphique est généré avec tw area [help twoway area].\nLes couleurs sont issues de la palette de type séquentielle YlGnBu de la collection Brewer (voir le chapitre sur les palettes de couleur). les codes des deux couleurs sont \"34 94 168\" et \"139 209 187\".\n\n\n\n\n\nGraphique(s) 2\n\nNuage de points des variables price et mpg pour les deux modalités de la variable foreign, avec report des OLS.\nLa droite de l’OLS est générée avec le type de graphique tw lfitci:\nCouleur de la droite : option clc()\nCouleur de remplissage l’intervalle de confiance: option fc()\nCouleur du contour de l’intervalle de confiance: option alc()"
  },
  {
    "objectID": "formation/formation13.html",
    "href": "formation/formation13.html",
    "title": "Options: légende, titre…",
    "section": "",
    "text": "legend(), clegend(), plegend: legend(contenu [options])\n\nLes options clegend() et plegend() sont réservées aux graphiques de type courbes de niveau avec une troisième dimension (hauteur, densité…): clegend() pour tw contour et plegend() pour tw contourline. Ces options ont des arguments spécifiques que je ne décrirais pas ici.\nStata utilise par défaut le label de la variable y pour alimenter le contenu de la légende, ce qui peut conduire à un rendu inadapté qu’il faudra corriger manuellement ou à l’aide de macros et fonctions macro (voir chapitre2).\n\nNe pas afficher une légende: legend(off).\nPosition par défaut: 6 heures (Sud) – à l’extérieur. Modifiable avec pos(#) et ring(0 ou 1).\nPour modifier le nombre de lignes et de colonnes: row(#) et col(#).\nPour modifier les labels de la légende:\norder(...) : order( 1 \"label1\" 2 \"label2\" .....) ou\nlab(...) : lab(1 \"label1\") lab(2 \"label2\") ...)\n\nJ’utilise de préférence order plus parcimonieux en parenthèses. L’apparence (gras, italique…) des labels est modifiable avec des balises smcl ; les tailles et couleurs sont également modifiables avec des options pour les textes.\n\nLes labels peuvent être reportés sous les symboles avec l’option stack.\nOn peut modifier l’aspect de la zône (couleur du fond, contour…) avec la sous option **region(...) ou r(...).\n\nLe smcl ::: {.callout-note} Le smcl\nLe Smcl « Stata Markup Control Langage » est le langage d’édition de Stata, il faut le reconnaître un peu préhistorique (ce n’est pas du Markup pour rien). Pour les graphiques, il permet de modifier les textes des titres, labels des axes, contenu des légendes : gras, italique… changement de police, ajout de formules.\nBalise smcl : \"{type_option: texte}\"\nQuelques options/modifications de base :\n\nGras : \"{bf: texte}\"\nItalique : \"{it: texte}\"\nGras et italique : \"{bf:{it :texte}}\"\n\nLe choix des polices dépend du système d’exploitation. Elles sont sélectionnées par leur type : \"{stSans : texte}\" pour type sans serif, \"{stSerif : texte}\" pour type serif, \"{stMono: texte}\" pour type mono, et \"{stSymbol : texte}\" pour les lettres grecques ou les symboles mathématiques. Exemples de polices avec windows : arial (sans serif), times new roman (serif), courrier new ou consolas (mono) et symbol (symbol). On peut également utiliser toutes les typographies disponibles en les sélectionnant en amont, avec la commande graph set.\n\n\nOptions de la légende :\n\nlegend(order(1 \"{bf:Domestic}\" 2 \"{bf:Foreign}\") pos(1) ring(0) col(1) region(lw(*.1)) stack )\n\n\nLe texte de labels a été mis en gras avec une balise Smcl.\nLa légende a été positionnée à l’intérieur du graphique avec ring(0) et à 1 heure avec pos(1).\nLa légende est reportée sous forme de colonne avec col(1).\nL’épaisseur du contour de la zône a été fortement réduit avec r(lw(*.1)).\nLe texte est positionné sous le symbole avec l’option stack."
  },
  {
    "objectID": "formation/formation13.html#changer-la-police-par-défaut",
    "href": "formation/formation13.html#changer-la-police-par-défaut",
    "title": "Options: légende, titre…",
    "section": "3.1 Changer la police par défaut",
    "text": "3.1 Changer la police par défaut\nOn peut paramétrer en amont la typographie utiliser par les graphiques avec la commande graph set\n\n* pour OS windows\ngraph set window fontface[type_police] \"nom_police\" \n\nLe type de police est: sans, serif, mono, symbol.\nPar défaut:\n\n   window           current\n   setting          default          choices\n   ----------------------------------------------------------------\n   fontface         Arial             font name\n   fontfacesans     Arial             font name\n   fontfaceserif    Times New Roman   font name\n   fontfacemono     Courier New       font name\n   fontfacesymbol   Symbol            font name\n   ---------------------------------------------------\n\nExemple: avec Trebuchet MS pour fontface et consolas pour mono\n\ngraph set window fontface\"trebuchet MS\"\ngraph set window fontfacemono \"consolas\"\n\n/*\n   window           current\n   setting          default          choices\n   ------------------------------------------------------------------------\n   fontface         trebuchet MS      font name\n   fontfacesans     Arial             font name\n   fontfaceserif    Minion Pro        font name\n   fontfacemono     consolas          font name\n   fontfacesymbol   Symbol            font name\n   ------------------------------------------------------------------------\n*/"
  },
  {
    "objectID": "formation/formation13.html#taille-du-graphique",
    "href": "formation/formation13.html#taille-du-graphique",
    "title": "Options: légende, titre…",
    "section": "3.2 Taille du graphique",
    "text": "3.2 Taille du graphique\nCes options sont particulièrement utiles pour les graphiques combinés lorsque l’empilement de plusieurs graphiques provoque un effet d’écrasement des axes (axes x plus court si plusieurs colonnes par exemple).\n\nxsize(#) - ysize(#) : en pouce (max=20). Peut s’appliquer à un graphique individuel, ou plus souvent à la commande graph combine pour retrouver un bon ratio x/y pour les sous graphiques.\nfxize(#) – fysize(#) : # en %. A utiliser seulement pour combiner des graphiques. Avant la combinaison on peut appliquer ces options aux graphiques individuels pour contrôler les ratios x/y. Cela permet plus de liberté dans les compositions des graphiques combinés.\n\nUne application est donnée plus loin dans la section dédiée aux graphiques combinés."
  },
  {
    "objectID": "formation/formation13.html#modifier-automatiquement-la-taille-du-texte-et-des-symboles",
    "href": "formation/formation13.html#modifier-automatiquement-la-taille-du-texte-et-des-symboles",
    "title": "Options: légende, titre…",
    "section": "3.3 Modifier automatiquement la taille du texte et des symboles",
    "text": "3.3 Modifier automatiquement la taille du texte et des symboles\nscale(#) – **iscale(#)*\nPermet de modifier la taille des éléments types texte et symboles générés par un graphique. Utile lorsque le texte d’une légende sort du contour. Valeur de référence=1.\nPour la commande graph combine, on utilise l’option iscale() qui appliquera la modification à tous les sous graphiques."
  },
  {
    "objectID": "formation/formation13.html#options-daffichage-et-denregistrement",
    "href": "formation/formation13.html#options-daffichage-et-denregistrement",
    "title": "Options: légende, titre…",
    "section": "3.4 Options d’affichage et d’enregistrement",
    "text": "3.4 Options d’affichage et d’enregistrement\n\nnodraw\nEquivalent de quietly pour les graphiques, il permet de ne pas afficher le graphique dans l’éditeur. Plutôt à utiliser pour les sous-graphiques qui seront combiner ou associer à l’option saving(). Cela permet de gagner un temps d’exécution non négligeabe.\nname(): name(nom_graph [,replace])\nPermet de sauvegarder temporairement le graphique sur la session. On peut privilégier cette option pour combiner des graphiques ultérieurement.\nUtiliser de préférence l’option replace pour écraser un graphique déjà en mémoire et avec un même nom, à défaut de quoi il faut supprimer le ou les graphiques en mémoire avec graph drop noms_graphs ou graph drop _all en amont.\ngraph display [nom_graph]\nPermet d’afficher un graphique en mémoire (non sauvegardé en dur). Si le nom du graphique n’est pas précisé, le dernier graphique généré est ouvert dans l’éditeur de graphique.\n\nExemple:\n\n graph display g1\n\n\nsaving(\"path/nom\"[, replace])\nMême principe que name(), mais sauvegarde en dur sur le disque.\ngraph use \"nom_graph\"\nPermet d’afficher un graphique enregistré.\nExporter un graphique\nexport nom_graph.format [, replace name(nom du graphique ouvert dans l’éditeur)]. Stata peut convertir un graphique en plusieurs format : jpeg, png, gif (seulement mac), svg…. On peut le faire directement dans l’éditeur de graphique ou passer par la ligne de commande export. Pour utiliser cette commande, le graphique doit être ouvert dans l’éditeur. Les formats d’exportation on des options propres.\n\nExemples:\n\ntw line y x\ngraph export graphpng.png\ntw line y x, name(g1,replace)\ngraph export graphpng.png, replace name(g1)"
  },
  {
    "objectID": "formation/formation14.html",
    "href": "formation/formation14.html",
    "title": "Combiner des graphiques",
    "section": "",
    "text": "Les facettes ou small multiples permet de combiner rapidement plusieurs graphiques répétés pour différentes valeurs d’une variable additionnelle, généralement catégorielle. Stata est plutôt efficace pour produire ce genre de visualisation avec l’option by() dans la commande graphique. On peut néanmoins regretter le manque de possibilité concernant l’habillage des sous graphiques avec, par exemple, une même couleur imposée à l’ensemble des sous graphiques.\nSyntaxe : graphique, by(variable [, total col(#) row(#)…])…\nAvec l’argument total en option de by(), on peut ajouter un graphique additionnel représentant le graphique avec toutes les valeurs, donc celui sans l’option by. On peut également modifier la répartition des sous-graphiques par ligne et colonne avec row() et col(). Le graphique génère automatiquement une note « Graphs by nom_variable » plutôt dispensable. Si l’on souhaite supprimer cette note, on ajoute note(\" \") en option de by().\nExemple\n\nsysuse lifeexp\n#delimit ;\ntw scatter lexp gnppc, \nby(region, total note(\" \"))\nmc(\"31 161 135%70\") mlc(black) mlw(*.6)\n\nxlabel(1000 \"1k\" 5000 \"5k\" 10000 \"10k\" 15000 \"15k\" 20000 \"20k\" , alt)\nxscale(log)\n;\n\n\n\n\n\nDeux commandes sont disponibles pour combiner plusieurs sous-graphique:\n\ngraph combine: commande officielle.\ngrc1leg: commande externe qui permet d’afficher une seule légende lorsque les sous graphiques partagent la même légende. Installation : ssc install grc1leg.\n\n\n\n\nLes sous-graphiques devant être enregistrés, préférer name(nom, replace) à save(path/nom, replace).\nUne fois les sous-graphiques validés, utiliser l’option nodraw pour raccourcir le temps d’exécution.\nmargin(#1 #2 #3 #4) : si l’on souhaite modifier l’espace entre les sous graphiques on peut utiliser cette sous-option de l’option graphr(). Par défaut margin(0 0 0 0) avec margin(left right top bottom). L’application en fin de section précisera par l’exemple l’intérêt de cette option. Voir également imargin() plus bas pour appliquer automatiquement une modification identique à tous les sous graphiques.\nLorsqu’un graphique sera combiné à un autre, les options xsize() et ysize() sont sans effet. On peut alors utiliser les options fxsize() et fysize(). De même, l’option scale(#) est sans effet et sera remplacée par l’option iscale() du graphique combiné.\nGénérer un graphique vide: en particulier lorsque le nombre de sous-graphiques est impair, on peut générer un ou plusieurs graphiques vides pour ajouter un titre, une note…., ou affiner la mise en page. La syntaxe de ce graphique est donnée ci-dessous, ainsi qu’un moyen de récupérer facilement sa syntaxe via une macro enregistrée en dur.\n\nGraphique vide\nSyntaxe\n\ntw scatteri 1 1, ylab(,nogrid) xlab(,nogrid) mc(%0) xtitle(\"\") ytitle(\"\") yscale(off noline) xscale(off noline) name(gv,replace) \n\nPour récupérer cette syntaxe on peut l’enregistrer dans une macro en dur, de type global. On peut soit exécuter directement ce graphique vide, soit le modifier pour ajouter, par exemple, un élément de type texte, ou modifier son habillage comme la couleur de fond.\nEnregistrement dans une macro\n\nglobal gvide \"scatteri 1 1, ylab(,nogrid) xlab(,nogrid) mc(%0) xtitle(\"\") ytitle(\"\") yscale(off noline) xscale(off noline) name(gv,replace)\"\n\nExécution directe du graphique vide sans affichage (ajout de nodraw)\n\ntw $gvide nodraw\n\nRécupération de la syntaxe et ajout d’un texte libre et modifier l’habillage\n\nmac list gvide\ntw $gvide text(1 1 \"MON TEXTE\", color(white)) ///\n          graphr(color(gs8)) plotr(color(gs8))\n\n\n\n\n\nSyntaxe générique\n\ngraph combine liste_sousgraph [, col() row() xsize() ysize() iscale() xcommon \nycommon …..]\n\n\ngrc1leg graph combine liste_sousgraph [, legendfrom(nom_graph) col() row() xsize() ysize() iscale() xcommon ycommon…..]\n\n Options du graphique combiné\n\ncol(#) et row(#) permettent d’indiquer le nombre de colonnes et de lignes pour la mise en page.\nxsize(#) et ysize(#) permettent de contrôler les effets d’écrasement si le nombre de colonnes et de ligne n’est pas identique. max(#)=15.\niscale(#) permet de réduire les éléments types texte et symbole pour l’ensemble des sous graphique (remplace scale() pour un graphique individuel).\nimargin(#1 #2 #3 #4) modifie pour chaque sous graphique la distance en la limite de la zône du graph (graphr) et le bord du graphique. Dans l’ordre imargin(left right top bottom). Par défaut imargin(0 0 0 0), des valeurs positives augmentent la distance, des valeurs négatives la réduise.\nxcommon et ycommon forcent les graphiques à partager les même valeurs pour les axes.\nlegendfrom(nom_graph): pour la commande grc1leg seulement, permet d’afficher une seule légende lorsque les sous-graphiques partage la même.\n\n Application\nL’idée est de proposer un graphique devenu assez standard en visualisation, représentant pour deux variables continues leur distribution croisée, ici sous forme d’un nuage, et leur distribution marginale, ici sous forme d’histogramme. Ce type de graphique est également souvent représenté dans une version combinant des courbes de niveaux et des densités simples.\nOn prendra ici de nouveau les variables price et mpg de la base auto.\nDans un premier temps on combinera simplement les 3 graphiques, dans un second temps on ajoutera un graphique vide avec un élément titre à la seconde colonne de la première ligne, enfin on proposera un graphique définitif avec deux variantes, qui modifie la position du titre.\nAu niveau des options je n’ai pas reporté les altérations du style par défaut pour alléger le report de la syntaxe.\nGraphique combiné simple\n\nsysuse auto\n#delimit ;\nhistogram price, bin(20) freq\nfc(\"31 161 135%70\") lc(%0) mlw(*6)  \nname(g1,replace) \n;\nhistogram mpg, bin(20) freq\nfc(\"31 161 135%70\") lc(%0) \nname(g2,replace) \n;\ntw scatter price mpg,  \nmc(\"31 161 135%70\") mlc(black) mlw(*.6)  \njitter(1) \nname(g3,replace)\n;\ngraph combine g1 g2 g3, title(\"Prix et consommation\")\n;\n\n\nOn ajoute un graphique vide dans lequel on indiquera le titre du graphique, et on positionne l’histogramme de la variable price à l’horizontal (option horizontal) :\n\ntw $gvide title(\"Prix et\" \"consommation\")\n\n#delimit ;\nhistogram price, bin(20) freq\nfc(\"31 161 135%70\") lc(%0) mlw(*6)  \nhorizontal\nname(g1,replace) \n;\n\nhistogram mpg, bin(20) freq\nfc(\"31 161 135%70\") lc(%0) \nname(g2,replace) \n;\n\ntw scatter price mpg,  \nmc(\"31 161 135%70\") mlc(black) mlw(*.6)  \njitter(1) \nname(g3,replace)\n;\ngraph combine g2 gv g3 g1 ;\n\n\nPour la version suivante, on va réduire la taille des abscisses pour g1 (price) et le graphique vide, la taille des ordonnées pour g2 (mpg) et le graphique vide avec fxsize(#) et fysize(#). On va également cacher plusieurs titres et labels d’axes et réduire les distances d’espacement entre les sous graphiques avec l’option imargin(#1 #2 #3 #4) de graph combine. La distance d’espacement avec le bord du graphique combiné sera par contre augmentée pour compenser. Titres et labels d’axes seront cachés et non pas supprimés. Si on les enlève, on modifie le ratio d’affichage du graphique et les axes reportés ne seront pas correctement ajustés entre le nuage et les histogrammes. Visuellement cela augmente la distance de séparation entre les graphiques, d’où sa réduction avec imargin().\nModification des tailles des sous graphiques:\n\nhistogramme de price (g1): fxsize(50)  fysize(100)\nhistogramme de mpg (g2): fxsize(100) fysize(50)\ngraphique vide (gv): fxsize(50)  fysize(50)\n\nTitres et labels des axes cachés:\n\ntitre: title(, color(0%)\nlabel: xlabel(,labc(%0)) ylabel(,labc(%0))\n\nModification des distances avec les bords: Pour les sous graphiques, comme on applique la même modification, on utilise l’option imargin(-5 -5 -5 -5) de graph combine. C’est équivalent à utiliser pour chaque sous graphique graphr(margin(-5 -5 -5 -5). Pour que la distance entre les bords extérieurs des sous-graphiques ne soient pas trop proche de la limite du graphique combiné, on augmente la distance avec graphr(margin(5 5 5 5)) appliqué en option de graph combine.\n\n#delimit ;\nhistogram price, bin(20) freq\nfc(\"31 161 135%70\") lc(%0) mlw(*6) \nhorizontal \nxtitle(, color(%0)) \nytitle(, color(%0)) \nxlabel(,glw(*.2)) \nylabel(, labc(%0) glw(*.3))\nfxsize(50) fysize(100)\nname(g1,replace) \n; \n\nhistogram mpg, bin(20) freq\nfc(\"31 161 135%70\") lc(%0) \nxtitle(,color(%0)) \nytitle(,color(%0)) \nylabel(, glw(*.2)) \nxlabel(, labc(%0) glw(*.3))\nfxsize(100) fysize(50)\nname(g2,replace) \n; \n\ntw scatter price mpg,  \nmc(\"31 161 135%70\") mlc(black) mlw(*.6)  jitter(1) \nfxsize(100) fysize(100)\nname(g3,replace)\n;\n\ngraph combine  g2 gv g3 g1, \nxsize(20) ysize(20) col(2) imargin(-5 -5 -5 -5) graphr(margin(5 5 5 5))\n;\n\n\nLe positionnement du titre, à droite, n’apparait pas optimal. En inversant le sens de l’axe x pour l’histogramme de price, en cachant le titre de l’axe de price pour le nuage, et en combinant différemment les graphiques, on obtient un meilleur résultat.\n-Inversion de l’axe x pour l’histogramme de price : xscale(reverse) -Cache du titre de l’axe price pour le nuage : ylabel(, labc(%0)) -Modification de l’ordre des sous-graphique : graph combine gv g2 g1 g3"
  },
  {
    "objectID": "formation/formation21.html#macro-temporaire-local",
    "href": "formation/formation21.html#macro-temporaire-local",
    "title": "Rappels sur les macros",
    "section": "1.1 Macro temporaire: local",
    "text": "1.1 Macro temporaire: local\n Les macros de type temporaire (local) sont conservées en mémoire seulement le temps de l’exécution. Cependant en exécutant Stata avec Notebook Jupyter (librairie Stata Kernel – Kyle barron*), ce type de macro vont rester en mémoire d’une exécution à une autre, ce qui peut présenter des avantages, en particulier pour les graphiques. Les macros seront effacées à la fin de la session. Voir la section dédiée à Python.\nSyntaxe\n\nlocal nom [=] expression/opération\n\nlocal nom [=] “expression”\n\nlocal nom [=] `““expression””' \n\nlocal nom : fonction_macro           \n\nAppel de l’expression dans un programme\n\n`nom' \n\n“`nom'”\n\nTest/visualisation de l’expression\n\nmac list _nom\n\ndi `nom'  \n\ndi “`nom'”\n\n\n\nExemple 1: on veut enregistrer le résultat de l’opération 1 + 1\n\nlocal  x  1 + 1\n\nmac list _x\n_x:  1 + 1\n\n\ndi `x'\n2\n\nmac list ne renvoie pas le résultat de l’opération, alors qu’il a été bien généré. On doit utiliser l’opérateur d’affectation = .\n\nlocal x = 1 + 1\n\nmac list _x\n_x: 2\n\ndi `x'\n2\n\nExemple 2: on veut enregistrer l’expression ABC\n\nlocal x \"ABC\" // ou\nlocal x ABC\n\nmac list _x\n_x: ABC\n\ndi `x'\nABC not found\n\ndi \"`x'\"\nABC\n\nExemple 3 : On veut enregistrer l’expression ABC avec les doubles quotes apparentes: “ABC”\n\nlocal x \"A\" \"B\" \"C\"\n\nmac list _x\n_x: A\" \"B\" \"C\n\ndi \"`x'\"\nABC\n\nLa solution précédente ne fonctionne pas.\n\nlocal x `\"\"A\" \"B\" \"C\"\"'\n\nmac list _x\n_x: \"A\" \"B\" \"C\"\n\ndi \"`x'\"\nA\" \"B\" \"C\" \" invalid name\n\ndi renvoie de nouveau un message d’erreur alors que la macro est correctement assignée.\nExemple 4: On alterne valeur numérique et du texte en conservant les doubles quotes.\n\nlocal no 0 \"Non\" 1 \"Oui\"\n\nmac list _no\n_no:     0 \"Non\" 1 \"Oui\"\n\ndi \"`no'\"\n0 Non\" 1 \"Oui\"\" invalid name\n\nRemarque: de nouveau di renvoie un message d’erreur alors que la macro est correctement assignée.\n\nlocal no 0 \"Non\" 1 \"Oui\"\n\nmac list _no\n_no:     0 \"Non\" 1 \"Oui\"\n\ndi \"`no'\"\n0 Non\" 1 \"Oui\"\" invalid name"
  },
  {
    "objectID": "formation/formation21.html#macro-en-dur-global",
    "href": "formation/formation21.html#macro-en-dur-global",
    "title": "Rappels sur les macros",
    "section": "1.2 Macro en dur: global",
    "text": "1.2 Macro en dur: global\nLes macros de type global sont enregistrées en dur, et conservées en mémoire d’une exécution à une autre et d’une session à une autre. Elles sont appelées avec $ et, avec mac list, le nom de la macro n’est pas précédé d’un underscore.\nTest/visualisation de l’expression\n\nmac list nom\n\ndi $nom  \ndi \"$nom\""
  },
  {
    "objectID": "formation/formation21.html#la-commande-levelsof",
    "href": "formation/formation21.html#la-commande-levelsof",
    "title": "Rappels sur les macros",
    "section": "1.3 La commande levelsof",
    "text": "1.3 La commande levelsof\nCette commande particulièrement utile, pour ne pas dire incontournable, récupère les valeurs d’une variable et les enregistre dans une macro temporaire. levelsof précède régulièrement l’utilisation d’une boucle de type foreach.\nSyntaxe: levelsof nom_var [if/in], local(nom_macro)\nExemple\n\nsysuse auto, clear\nlabel list origin\norigin:\n           0 Domestic\n           1 Foreign\n\nlevelsof foreign, local(f)\nmac list _f\n_f: 0 1\n\n\n\n\n\n\n\nglevelsof\n\n\n\nPour des grosses volumétries (>1M) il est conseillé d’utiliser la commande glevelsof de M.Caceres (package glevelsof):\n\ngtools\nglevelsof"
  },
  {
    "objectID": "formation/formation21.html#quelques-fonctions-associées-à-une-macro",
    "href": "formation/formation21.html#quelques-fonctions-associées-à-une-macro",
    "title": "Rappels sur les macros",
    "section": "1.4 Quelques fonctions associées à une macro",
    "text": "1.4 Quelques fonctions associées à une macro\nIl ne s’agit ici que de quelques fonctions utiles pour produire des graphiques et faciliter leur automatisation. L’ensemble des fonctions associées à une macro sont disponible dans l’aide (help macro).\n\n\n1.4.1 word count\nPermet de compter le nombre de termes contenus dans une expression enregistrée sous forme de macro. Utile pour compter le nombre de boucles à effectuer avec forvalue.\nSyntaxe: Local/global : word count(nom_macro)\nExemple\n\nlevelsof rep78, local(r)\n1 2 3 4 5\n\nlocal nombre: word count(`r')\n\nmac list _nombre\n_nombre:  5\n\n\n\n\n1.4.2 value label\nRécupère le nom d’un label affecté aux modalités d’une variable. Le nom de la variable peut-être enregistré en amont sous forme de macro.\nSyntaxe: local/global nom_macro : value label nom_variable/nom_macro\n\nlocal varname foreign\nlocal labn : value label `varname'\n\nmac list _labn\n_labn : origin\n\n\n\n\n1.4.3 label\nRécupère l’expression de la modalité associée à une valeur d’un nom de label. Le nom du label peut avoir été enregistré en amont dans une macro (avec par exemple la fonction value label).\nSyntaxe: local/global nom_macro : label nom_label valeur\nExemple:\n\nlocal lab0 : label origin 0\nlocal lab1 : label origin 0\n\nmac list _lab0\nlab0 : Domestic\n\nmac list _lab1\nlab1 : Foreign\n\nEn récupérant en amont le nom du label (origin).\n\nlocal labn: value label foreign\nlocal lab0: label `labn' 0\nlocal lab1: label `labn' 1\n\nmac list _lab0 _lab1\n_lab0 : Domestic\n_lab1 : Foreign\n\nEn récupérant les valeurs de la variable avec levelsof, la modalité de chaque valeur peut-être récupérée dans une boucle foreach.\n\nlevelsof foreign, local(v)\nlocal labn: value label foreign\n\nforeach val of local v {\nlocal lab`val': label `labn' `val'\n\nmac list _lab`val' \n}\n\n_lab0 : Domestic\n_lab1 : Foreign\n\nEn mettant dès le début une macro sur le nom de la variable, on automatise les modifications. Il est même possible de mettre dans la macro plusieurs variables, et effectuer l’opération dans une boucle principale.\n\nlocal X foreign\n\nlevelsof `X', local(v)\nlocal labn: value label `X'\n\nforeach val of local v {\nlocal lab`val': label `labn' `val'\nmac list _lab`val' \n}\n\n_lab0 : Domestic\n_lab1 : Foreign\n\nGraphique\nOn va récupérer automatiquement les modalités d’une variable pour renseigner la légende.\n\nLa variable rep78 est regroupée en 2 modalités.\nLes modalités de la légende sont automatiquement insérées dans l’expression legend(order(…)...).\nPour utiliser une autre variable que rep, il suffit de modifier le nom de la variable dans la première macro (X).\n\n\nsysuse auto, clear\ngen rep= rep78<4\nlabel define rep 0 \"rep<4\" 1 \"rep>=4\", modify\nlabel value rep rep\n\n*Récupération des modalités\nlocal X rep\nlocal labn: value label `X'\nlevelsof `X', local(l)\nforeach l2 of local l {\nlocal lab`l2': label `labn' `l2'\n}\n\n\n*Graphique\n#delimit ;\ntw scatter price mpg if `X', \n   mc(\"237 248 177\")   mlc(black) mlw(*.3)  msiz(*1.5) jitter(2)     \n|| scatter price mpg if !`X', \n   mc(\"65 182 196\")    mlc(black) mlw(*.3) msiz(*1.5) jitter(2)  \n   \n|| , legend(order(1 \"`lab0'\" 2 \"`lab1'\") pos(11) region(color(%0)))         \n     title(\"Variable `X'\") \n;\n#delimit cr\n\n\nIl suffit de modifier la première ligne qui enregistre le nom de la variable pour faire le même graphique avec la variable foreign: local X foreign.\n\nExercice\nA partir du programme faire un graphique combiné des deux graphiques précédents en automatisant au maximum la sélection des variables rep et foreign. Il y a très peu d’ajouts ou de modifications à faire.\n\n\n\n1.4.4 variable label\nRécupère le label d’une variable sous forme du macro. Utile pour gérer une modification du titre des axes passer par les lignes de programme d’un graphique, et plus généralement pour donner de l’information sur variable de type continu ou de comptage sans label affecté au valeurs.\nSyntaxe: local/global nom_macro : variable label variable/macro\n\nlocal labv:  variable label foreign\nmac list _labv\n\n_labv : car type\n\nModification du format d’une valeur numérique (changement du nombre de décimale)\nDans la section suivante, on va utiliser utiliser des objets de type macro qui sont générés après avoir exécuté une commande. Lorsque ces objets sont des valeurs statistiques comme des moyennes, estimateurs de regression etc., leur format enregistré comporte généralement un nombre important de décimales. Il est possible de modifier/réduire ce nombre de décimales avec la fonction di.\nSyntaxe: local/global nom_macro : di format valeur/macro\n\nlocal dec: di %6.2f 0.123456789\n\ndi `dec'\n.12"
  },
  {
    "objectID": "formation/formation21.html#return-et-ereturn",
    "href": "formation/formation21.html#return-et-ereturn",
    "title": "Rappels sur les macros",
    "section": "1.5 return et ereturn",
    "text": "1.5 return et ereturn\nAprès l’exécution d’une commande, un certain nombre d’objets sont conservés en mémoire jusqu’à l’exécution de la commande suivante. Leur liste est indiquée en bas du fichier d’aide.\n\nobjets return: r(nom_objet)\nAffichage de la liste: return list\nobjets ereturn: e(nom_objet)\nAffichage liste: ereturn list\n\n\nsum price, d\n                            Price\n-------------------------------------------------------------\n      Percentiles      Smallest\n 1%         3291           3291\n 5%         3748           3299\n10%         3895           3667       Obs                  74\n25%         4195           3748       Sum of Wgt.          74\n\n50%       5006.5                      Mean           6165.257\n                        Largest       Std. Dev.      2949.496\n75%         6342          13466\n90%        11385          13594       Variance        8699526\n95%        13466          14500       Skewness       1.653434\n99%        15906          15906       Kurtosis       4.819188\n\nreturn list\nscalars:\n                  r(N) =  74\n              r(sum_w) =  74\n               r(mean) =  6165.256756756757\n                r(Var) =  8699525.97426879\n                 r(sd) =  2949.495884768919\n           r(skewness) =  1.653433511704859\n           r(kurtosis) =  4.819187528464004\n                r(sum) =  456229\n                r(min) =  3291\n                r(max) =  15906\n                 r(p1) =  3291\n                 r(p5) =  3748\n                r(p10) =  3895\n                r(p25) =  4195\n                r(p50) =  5006.5\n                r(p75) =  6342\n                r(p90) =  11385\n                r(p95) =  13466\n                r(p99) =  15906\n\n\n\n\nqui sum, d\n\ndi r(mean)\n.54054054\ndi `r(mean)'\n.54054054\n\nlocal mean r(mean)\ndi `mean'\n.54054054\nmac list _mean\n.5405405405405406\n\nlocal mean : di %6.2f `r(mean)'\ndi `mean'\n0.54\nmac list _mean\n_mean : 0.54\n\nAu niveau d’un graphique ces objets permettent:\n\nD’afficher des valeurs dans un graphique.\nDe générer automatiquement des éléments de type xline yline.\nDe générer des graphiques de type scatteri ou pci qui entrent directement les coordonnées au lieu des variables.\n\nGraphique\nOn va tracer une droite sur chaque axe qui reporte les moyennes des variables price et mpg, les valeurs de ces moyennes sont reportés en bas du graphique en tant que note\n\nRécupération des moyennes de price et mpg\nles noms des macros seront mprice et * mpg*\n\n\nlocal varlist price mpg\nforeach v of local varlist {\nqui sum `v'\nlocal  m`v' : di %6.2f `r(mean)'\n}\n\n* Récupération des labels de la variable foreign\nlocal X foreign\nlocal labn: value label `X'\nlevelsof `X', local(l)\nforeach l2 of local l {\nlocal lab`l2': label `labn'  `l2'\n}\n\n* Graphique\n#delimit ; \ntw scatter price mpg if !foreign, \n   mlc(black) mlw(*.3) mc(\"254 196 79\") msiz(*1.5)  jitter(2) \n|| scatter price mpg if foreign,\n   mlc(black) mlw(*.3) mc(\"153 52 4\")   msiz(*1.5)  jitter(2) \n\n|| , legend(order(1 \"`lab0'\" 2 \"`lab1'\") pos(11) region(color(%0))) \n     yline(`mprice', lc(\"236 112 20\") lw(*1.5)) \n     xline(`mmpg'  , lc(\"236 112 20\") lw(*1.5))\n     note(\"{bf:Moyenne Price = `mprice'}\" \n        \"{bf:Moyenne Mpg   = `mmpg'}\")\n;\n#delimit cr"
  },
  {
    "objectID": "formation/formation21.html#compteurs-i",
    "href": "formation/formation21.html#compteurs-i",
    "title": "Rappels sur les macros",
    "section": "1.6 Compteurs i++",
    "text": "1.6 Compteurs i++\nLes compteurs vont s’avérer très utiles dans les expressions en boucle pour générer une valeur incrémentale de type macro. C’est sur ce principe que fonctionne les boucles de type forvalue, mais il est possible de les générer dans une boucle de type foreach.\nExemple1: on initialise un compteur i. Dans une boucle forvalue dont l’incrément va de 10 à 15 (\\(\\delta=+1\\)), on génère à chaque boucle une valeur allant de 1 à 6 avec la macro `i++'.\n\nlocal i = 1\n\nforvalue k = 10/15 {\ndi \"k=`k' => i=`i++'\"   \n}\n\n/*\nk=10 => i=1\nk=11 => i=2\nk=12 => i=3\nk=13 => i=4\nk=14 => i=5\nk=15 => i=6\n*/\n\nExemple 2: on va afficher les noms d’une liste de variable en noms génériques dans une boucle foreach.\n\nlocal i=1\nlocal varlist price mpg turn length\n\nforeach v of local varlist  {\ndi \"variable`i++' = `v'\"        \n}\n\nvariable1 = price\nvariable2 = mpg\nvariable3 = turn\nvariable4 = length\n\n Point de vigilance\n\n\n\n\n\n\nImportant\n\n\n\nAppels multiples d’un compteur dans une boucle. Dans les exemples précédents, le compteur n’a été utilisé qu’une fois dans une itération. Il est important de noter que le compteur peut continuer à incrémenter lorsqu’il est appelé plusieurs fois dans une itération. Nous allons présenter les différents comportements du compteur, et le moyen de fixer sa valeur dans une itération avec des appels multiples.\n\n\nSituation1: Un seul appel du compteur (cas standard)\n\nforv i=1/5 {\n  di \"iteration `i': i++ =\"  `i++' \n   }\n\n/*\niteration 1: i++ =1\niteration 2: i++ =2\niteration 3: i++ =3\niteration 4: i++ =4\niteration 5: i++ =5\n*/\n\nSituation2: Plusieurs appels dans une itération dans une boucle standard : la valeur du compteur est fixe dans chaque itération, mais pour la première et la dernière, le second appel est ignoré.\n\nforv i=1/5 {\ndi \"iteration `i': i++ =\"  `i++' \ndi \"iteration `i': i++ =\"  `i++' \n  }\n\n/*\niteration 1: i++ =1\n\niteration 2: i++ =2\niteration 2: i++ =2\n\niteration 3: i++ =3\niteration 3: i++ =3\n\niteration 4: i++ =4\niteration 4: i++ =4\n\niteration 5: i++ =5\niteration 5: i++ =5\n\niteration 6: i++ =6\n*/\n\nSituation3: On initialise le compteur en amont (k*), il continue d’incrémenter dans chaque itération.\n\nlocal k=1\nforv i=1/5 {\n  di \"iteration `i': \"  `k++'\n  di \"iteration `i': \"  `k++'\n  }\n\n/*\niteration 1: 1\niteration 1: 2\n\niteration 2: 3\niteration 2: 4\n\niteration 3: 5\niteration 3: 6\n\niteration 4: 7\niteration 4: 8\niteration 5: 9\n\niteration 5: 10\n*/\n\nSituation4: le compteur est appelé plusieurs fois. On veut fixer sa valeur pour qu’elle soit égale à la valeur de l’itération, sans rencontrer le problème de la situation2 avec un appel simple à la première et dernière itération. On va devoir initialiser un nouveau compteur à l’intérieur de la boucle, à chaque itération (compteur j).\n\nlocal k=1\nforv i=1/5 {\n local j = `k++'\n di \"iteration `i': \"  `j'\n di \"iteration `i': \"  `j'\n  }\n\niteration 1: 1\niteration 1: 1\n\niteration 2: 2\niteration 2: 2\n\niteration 3: 3\niteration 3: 3\n\niteration 4: 4\niteration 4: 4\n\niteration 5: 5\niteration 5: 5\n\nSi le compteur est utilisé plusieurs dans une itération et que sa valeur y doit être fixe, on devra donc utiliser cette dernière expression.\nGraphique\nLe graphique suivant donne la distribution de la variable displacement selon le nombre de réparation (variable rep78). Pour chaque valeur de rep78, la moyenne de displacement est reportée. Ces moyennes sont connectées à la moyenne calculée sur l’ensemble des voitures. On retrouve le principe d’un graphique de type « lollipop ».\n\nlocal i=1\nlevelsof rep78, local(l)\nforeach v of local l {\nqui sum displacement  if rep78==`v'\nlocal m`i++' = `r(mean)'\n}\n\nqui sum displacement \nlocal mean `r(mean)'\n\n#delimit ;\ntw  scatteri 2 `m1',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n||  scatteri 3 `m2',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n||  scatteri 4 `m3',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n||  scatteri 5 `m4',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n\n|| pci 2 `mean' 5 `mean', lw(*2.5) lc(\"210 50 0\")\n|| pci 2 `mean' 2 `m1'  , lw(*2.5) lc(\"210 50 0\")\n|| pci 3 `mean' 3 `m2'  , lw(*2.5) lc(\"210 50 0\")\n|| pci 4 `mean' 4 `m3'  , lw(*2.5) lc(\"210 50 0\")\n|| pci 5 `mean' 5 `m4'  , lw(*2.5) lc(\"255 50 0\")\n\n||  scatter rep78 displacement,  mc(\"255 117 0%70\") mlc(210 50 0) mlw(*.5) msize(*1) jitter(5) || , \n\nxlabel(,glw(*1.2)) ylabel(,glw(*.5) angle(0)) yscale(range(1.8, 5.2))\nlegend(off)\ntitle(\"Averages of displacement\") ytitle(\"Number of repairs\")\n\n\nPas à pas du programme\n\nrecode rep78 (1=2)\n\nlocal i=1\nlevelsof rep78, local(l)\nforeach v of local l {\nqui sum displacement  if rep78==`v'\nlocal m`i++' = `r(mean)'\n}\n\nqui sum displacement \nlocal mean `r(mean)'\n\n\nOn regroupe les deux premières valeurs de rep78 (peu d’observations).\nOn initialise le compteur qui sera utilisé dans une boucle foreach.\nOn récupère les valeurs de la variable rep78 avec levelsof.\nDans la boucle on récupère les valeurs des moyennes de displacement pour chaque valeur de rep78. Elles sont enregistrées dans les expressions macro m1 à m4. Les valeurs 1 à 4 sont générées par le compteur i++.\nOn récupère la moyenne pour l’ensemble des voitures. Elle est enregistrée dans la macro mean.\n\n\n#delimit ;\ntw  scatteri 2 `m1',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n||  scatteri 3 `m2',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n||  scatteri 4 `m3',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n||  scatteri 5 `m4',  msymbol(|) mc(\"210 50 0\") msize(*5) mlw(*3)\n\n|| pci 2 `mean' 5 `mean', lw(*2.5) lc(\"210 50 0\")\n\n|| pci 2 `mean' 2 `m1'  , lw(*2.5) lc(\"210 50 0\")\n|| pci 3 `mean' 3 `m2'  , lw(*2.5) lc(\"210 50 0\")\n|| pci 4 `mean' 4 `m3'  , lw(*2.5) lc(\"210 50 0\")\n|| pci 5 `mean' 5 `m4'  , lw(*2.5) lc(\"255 50 0\")\n\n|| scatter rep78 displacement, mc(\"255 117 0%70\") mlc(210 50 0) mlw(*.5)\n   msize(*1) jitter(5)\n\n|| , xlabel(,glw(*1.2)) ylabel(,glw(*.5) angle(0)) yscale(range(1.8, 5.2))\n     legend(off)\n     title(\"Averages of displacement\") ytitle(\"Number of repairs\");\n\n#delimit cr\n\n\nPour faciliter l’écriture et la lecture du programme on change de type de délimiteur.\nLes moyennes par niveau de réparation seront en arrière plan pour visualiser les valeurs de toutes les voitures.\nOn utilise scatteri pour générer le nuage des moyennes pour chaque niveau de réparation. Les valeurs de ces dernières sont connues (de 2 à 5) et les moyennes de displacement on été enregistrées dans les macros m1 à m4. Pour le premier niveau de réparation le nuage est donc généré par **scatteri 2 m1'** [scatteri valeur_Y valeur_X]. On a utilisé un symbole de type ***pipe*** au lieu d’une bulle [msymbol(|)`].\nOn trace une droite verticale avec la fonction pci pour indiquer la moyenne de displacement pour l’ensemble des voitures. La valeur de cette moyenne (X) a été calculée en amont (macro mean) et on connait les valeurs de Y. La droite est donc générée par pci 2 mean' 5mean’ [pci min_Y min_X max_Y max_X].\nOn va connecter la valeur des moyennes pour chaque niveau de réparation avec la moyenne d’ensemble. On va ici tracer des droites horizontale, dont les coordonnées Y seront cette fois ci fixe, et le minimum de X toujours égal à la moyenne d’ensemble. Pour le premier niveau de réparation : pci 2 mean' 2m1’.\n\nRemarque: on pourrait améliorer le rendu de l’angle pour la connection des moyennes en modifiant légèrement les valeurs de Y_min et Y_max pour la droite verticale, avec par exemple : pci 1.985 mean' 5.015mean’, lw(2.5) lc(“210 50 0”)*."
  },
  {
    "objectID": "formation/formation21.html#autres-objets-macro-token-tempvar",
    "href": "formation/formation21.html#autres-objets-macro-token-tempvar",
    "title": "Rappels sur les macros",
    "section": "1.7 Autres objets macro: token, tempvar",
    "text": "1.7 Autres objets macro: token, tempvar\n\n1.7.1 Token\nLes tokens sont régulièrement utilisés dans la programmation de routines (.ado), mais peuvent dans un programme courant s’avérer utile pour transformer les noms variables en macros. Le token est une macro qui prend comme expression une liste de numéros : 1',2’, 3'…… On transforme une expression en token avec la commande **tokenize`**.\n\ntokenize price mpg\nsum `1' `2'\n/*\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n       price |         74    6165.257    2949.496       3291      15906\n         mpg |         74     21.2973    5.785503         12         41\n*/\n\nOu avec une expression sous forme de macro:\n\nlocal varlist price mpg\ntokenize `varlist'\nsum `1' `2'\n\nApplication pour un graphique:\n\nlocal varlist price mpg foreign \ntokenize `varlist'\ntw scatter `1' `2' if !`3'\n|| scatter `1' `2' if  `3'\n\n\n\n1.7.2 Variables temporaires\nVariables, fichiers… peuvent être créés de manière temporaire. On regardera seulement les variables temporaires générées avec la fonction tempvar nom_variable, elles sont appelées sous forme de macro temporaire : commandnom_variable’`. Principalement, elles permettent de générer des variables dont le nom n’entre pas en conflit avec des variables existantes, le nom enregistré étant de la forme** _00000#**, tout en n’alourdissanrpas artificiellement le contenu de la base.\n\nset obs 100\nnumber of observations (_N) was 0, now 100\n\ntempvar x\ngen `x' = runiform() \ndes\n/*\n----------------------------------------------------------------------------------\n              storage   display    value\nvariable name   type    format     label      variable label\n----------------------------------------------------------------------------------\n__000000        float   %9.0g \n----------------------------------------------------------------------------------       \n*/\n\nsum `x'\n/*\n\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n    __000000 |        100    .5253147    .2740814   .0073346   .9979447\n*/\n\n\ntempvar x\ngen `x' = runiform()\ndes\n/*\n----------------------------------------------------------------------------------\n              storage   display    value\nvariable name   type    format     label      variable label\n----------------------------------------------------------------------------------\n__000000        float   %9.0g                 \n__000001        float   %9.0g                 \n----------------------------------------------------------------------------------\n*/\n\n/*\nsum `x'\n    Variable |        Obs        Mean    Std. Dev.       Min        Max\n-------------+---------------------------------------------------------\n    __000001 |        100     .471744    .2926945   .0028599   .9711645\n*/    \n\nGraphique\nOn va de nouveau représenter un nuage de points, entre la variable price et la variable displacement. La couleur des bulles représente l’appartenance à un quartile de la variable displacement.\n\nsysuse auto, clear\ntempvar qdisp\nlocal varlist price displacement `qdisp'\ntokenize `varlist'\nqui xtile `qdisp' = `2', n(4)\nqui sum `2', d\n\n#delimit ;\ntw scatter `1' `2' if `3'==1,\n   mlc(black) mlw(*.5) mc(\"68 1 84%60\")    msiz(*1.5) jitter(1)\n|| scatter `1' `2' if `3'==2,\n   mlc(black) mlw(*.5) mc(\"49 104 142%60\") msiz(*1.5) jitter(1)\n|| scatter `1' `2' if `3'==4,\n   mlc(black) mlw(*.5) mc(\"53 183 121%60\") msiz(*1.5) jitter(1)\n|| scatter `1' `2' if `3'==3,\n   mlc(black) mlw(*.5) mc(\"253 231 37%60\") msiz(*1.5) jitter(1)\n\n||, legend(off) \n    xlabel(`r(p25)' \"`r(p25)'\" `r(p50)' \"`r(p50)'\" `r(p75)' \"`r(p75)'\")\n;"
  },
  {
    "objectID": "formation/formation22.html",
    "href": "formation/formation22.html",
    "title": "Alleger la syntaxe",
    "section": "",
    "text": "… et surtout faciliter les changements d’options.\nOn le voit, les d’options sont répétées d’un objet graphique à un autre, et souvent en grand nombre. Les modifications de l’habillage du graphique avec les couleurs, les tailles/épaisseurs, peuvent alors s’avérer laborieuse.\nDe manière très simple, les options communes à plusieurs objets ou éléments du graphique peuvent être renseignées en amont, sous forme de macros. Cela facilite grandement la modification des options.\nPrenons le graphique suivant avec un habillage assez poussé qui modifie les couleurs par défauts des titres et couleurs de fonds. Pour chaque nuage la taille de la bulle, la couleur et l’épaisseur du contour sont identiques, les titres partagent les mêmes couleurs, ainsi que les deux éléments du background.\n\ngraph set window fontface Magneto\n\ntempvar rep\ngen    `rep' = rep78\nrecode `rep' (1=2)  \n\n#delimit ;\ntw scatter price mpg if `rep'==2, mc(\"145 50 5\")    mlw(*.5) mlc(black)  msiz(*1.5)  \n|| scatter price mpg if `rep'==3, mc(\"221 95 11\")   mlw(*.5) mlc(black)  msiz(*1.5)  \n|| scatter price mpg if `rep'==4, mc(\"254 162 50\")  mlw(*.5) mlc(black)  msiz(*1.5)  \n|| scatter price mpg if `rep'==5, mc(\"254 211 112\") mlw(*.5) mlc(black)  msiz(*1.5)    \n\n|| , legend(off)                                                                           \n                              \nylabel(, labc(\"254 211 112\") glc(\"254 211 112\") glw(*.2) angle(0))                                \nxlabel(, labc(\"254 211 112\") glc(\"254 211 112\") glw(*.2)) \n                               \nytitle(, color(\"254 211 112\")) \nxtitle(, color(\"254 211 112\"))                               \ntitle(\"Price versus Mpg\", color(\"254 211 112\") pos(11)) \n\ngraphr(color(\"102 37 6*4\"))  plotr(color(\"102 37 6*4\"))      \n;\n\n\nEn mettant les options sous forme de macro et en les appelant dans la commande graphique, visuellement la syntaxe du graphique est nettement allégée :\n\ntempvar rep\ngen    `rep' = rep78\nrecode `rep' (1=2)  \n\nlocal mopt \"mlw(*.5) mlc(black) msiz(*1.5)\"\nlocal col1 \"254 211 112\"\nlocal col2 \"102 37 6*4\"\n\n#delimit ;\ntw scatter price mpg if `rep'==2, mc(\"145 50 5\")    `mopt'   \n|| scatter price mpg if `rep'==3, mc(\"221 95 11\")   `mopt' \n|| scatter price mpg if `rep'==4, mc(\"254 162 50\")  `mopt'\n|| scatter price mpg if `rep'==5, mc(\"254 211 112\") `mopt'   \n\n|| , legend(off)                                                                                                     \n     ylabel(, labc(`col1') glc(`col1') glw(*.2) angle(0))                                \n     xlabel(, labc(`col1') glc(`col1') glw(*.2)) \n     ytitle(, color(`col1')) xtitle(, color(`col1'))                               \n     title(\"Price versus Mpg\", color(`col1') pos(11)) \n     graphr(color(`col2'))     plotr(color(`col2'))      \n;\n\n\nLa modification des options est réalisée une seule fois en modifiant l’expression des macros.\nPar exemple, en changeant quelques couleurs (coutours et titres) et en ajoutant un jitter:\n\nlocal mopt \"mlw(*.5) mlc(white) m()  msiz(*1.5) jitter(2)\"\nlocal col1 white\nlocal col2 black\n\n#delimit ;\ntw scatter price mpg if `rep'==2, mc(\"145 50 5\")    `mopt'   \n|| scatter price mpg if `rep'==3, mc(\"221 95 11\")   `mopt' \n|| scatter price mpg if `rep'==4, mc(\"254 162 50\")  `mopt'\n|| scatter price mpg if `rep'==5, mc(\"254 211 112\") `mopt'   \n\n|| , legend(off)                                                                           \n     ylabel(, labc(`col1') glc(`col1') glw(*.2) angle(0))                                \n     xlabel(, labc(`col1') glc(`col1') glw(*.2)) \n     ytitle(, color(`col1')) xtitle(, color(`col1'))                               \n     title(\"Price versus Mpg\", color(`col1') pos(11)) \n     graphr(color(`col2'))  plotr(color(`col2'))      \n;"
  },
  {
    "objectID": "formation/formation23.html",
    "href": "formation/formation23.html",
    "title": "Automatiser la programmation",
    "section": "",
    "text": "Danger\n\n\n\nLes informations qui vont suivre demande un minimum de pratique avec la manipulation des macros Stata."
  },
  {
    "objectID": "formation/formation23.html#syntaxe-type",
    "href": "formation/formation23.html#syntaxe-type",
    "title": "Automatiser la programmation",
    "section": "1.1 Syntaxe type",
    "text": "1.1 Syntaxe type\nExemple : On veut obtenir la chaîne de caractère «A B C » à partir des trois éléments distincts « A », « B » et « C ».\nAvec une macro standard:\n\nlocal expression A B C \nforeach e of local expression {\n  mac list _ms\n  }\n/*  \n_ms : A\n_ms : B\n_ms : C\n*/\n\n\nmac list _ms\n* _ms: C\n\nDans chaque itération, chaque expression a bien été enregistrée, mais elle est écrasée à l’itération suivante. On pourrait à chaque itération enregistrer chaque macro et les empiler à l’extérieur de la boucle, mais il est possible de le faire automatiquement avec une macro dite « empilée ».\n La syntaxe est simple, on appelle la macro dans l’expression qui la génère, ce qui permet de la garder en mémoire à chaque boucle.\nSyntaxe:\n\nlocal nom_macro  `nom_macro'    expression\nglobal nom_macro  $nom_macro    expression \n\nAvec une macro empilée:\n\nlocal expression A B C \n\nforeach e of local expression {\n\nlocal me `me' `ms'\nmac list _me\n}\n\n/*A chaque itération\n_me:            A\n_me:            A B\n_me:            A B C\n*/\n\n*Expression finale enregistrée \nmac list _me\n* _me:            A B C"
  },
  {
    "objectID": "formation/formation23.html#automatiser-la-création-du-graphique",
    "href": "formation/formation23.html#automatiser-la-création-du-graphique",
    "title": "Automatiser la programmation",
    "section": "1.2 Automatiser la création du graphique",
    "text": "1.2 Automatiser la création du graphique\nPour un graphique, une application évidente est d’alléger et automatiser une syntaxe qui empile plusieurs objets graphiques de même nature. Si on reprend un type de nuage de points déjà exécuté de nombreuses fois dans ce document:\n\ntw scatter price mpg if rep78==1\n|| scatter price mpg if rep78==2\n|| scatter price mpg if rep78==3\n|| scatter price mpg if rep78==4\n|| scatter price mpg if rep78==5\n\nAvec une macro empilée:\n\n* On génère la syntaxe\nlevelsof rep78, local(l)\nforeach v of local l {\nlocal scat `scat' scatter price mpg if rep78==`v' ||\n}\n\n* Exécution du graphique\ntw `scat' , legend(off)\n\nCe qui est généré par la macro à chaque itération :\nItération 1:\n\nscatter price mpg if rep78==1 ||\n\nItération 2:\n\nscatter price mpg if rep78==1 || scatter price mpg if rep78==2 ||\n\nItération 3:\n\nscatter price mpg if rep78==1 || scatter price mpg if rep78==2 || \nscatter price mpg if rep78==3 ||\n\nItération 4\n\nscatter price mpg if rep78==1 || scatter price mpg if rep78==2 || \nscatter price mpg if rep78==3 || scatter price mpg if rep78==4 ||\n\nItération 5\n\nscatter price mpg if rep78==1 || scatter price mpg if rep78==2 || \nscatter price mpg if rep78==3 || scatter price mpg if rep78==4 || \nscatter price mpg if rep78==5 ||\n\nC’est la dernière qui est finalement enregistrée et il ne manque plus qu’à l’appeler après tw. Au-delà de l’allègement de la syntaxe du grap recode rep78 (1=2) hique cette manière de procéder automatise des modifications faites en amont, par exemple ici un regroupement de modalités de la variable rep78.\n\n*Il n’est pas nécessaire de modifier le graphique\n\nlevelsof rep78, local(l)\nforeach v of local l {\nlocal scat `scat' scatter price mpg if rep78==`v' ||\n}\ntw `scat' , legend(off)"
  },
  {
    "objectID": "formation/formation23.html#générer-une-légende",
    "href": "formation/formation23.html#générer-une-légende",
    "title": "Automatiser la programmation",
    "section": "1.3 Générer une légende",
    "text": "1.3 Générer une légende\nSur le même principe, on peut générer automatiquement une légende. L’opération peut néanmoins s’avérer un peu plus délicate, en raison du contrôle des doubles quotes pour les labels.\nDans un premier temps on ne va pas utiliser les fonctions macro qui permettent de récupérer automatiquement les noms et le contenu des labels.\nSans les fonctions macro:\n\nlocal l1 `\"\"Domestic\"\"'\nlocal l2 `\"\"Foreign\"\"'\nforvalue i=1/2 {\nlocal ord `ord' `i' `l`i''\n}\n\nmacro list _ord\n* _ord: 1 \"Domestic\" 2 \"Foreign\"\n\n#delimit ; \ntw scatter price mpg if !foreign\n|| scatter price mpg if  foreign\n||, legend(order(`ord'))\n;\n\nRappel: pour la légende on doit explicitement récupérer les doubles quotes pour les expressions qui seront affichées dans la légende: local nom_macro `““expression”“’\nAvec les fonctions macro:\nLes fonctions utilisées sont value label pour récupérer le nom du label et lab pour récupérer l’expression affectée à la modalité. Comme les expressions de la légende vont être récupérées via des macros on va accroître le nombre de quotes, ce qui peut s’avérer fastidieux pour lire le programme et éventuellement le modifier. Dans le programme qui suit on va générer automatiquement la syntaxe principale du graphique avec une macro empilée, comme expliqué précédemment. Les noms des variables seront également transformés en token. Pour anticiper un changement de variable de stratification, ici foreign, on va utiliser un compteur pour automatiser le nombre d’éléments contenu dans la légende.\n\nlocal varlist price weight foreign\ntokenize `varlist'\n\n* Légende\nlocal labn: value label `3' // on récupère le nom du label\nlevelsof `3', local(l)\nlocal i=1\nforeach l2 of local l {\nlocal lab`l2': label `labn' `l2' // on récupère l’expressions pour chaque valeur\nlocal lab`l2' `\"\"`lab`l2''\"\"'    // on transforme l’expressions en macro     \nlocal ord `ord' `i++' `lab`l2''  // on génère la syntaxe de la légende\n}\n\n* Graphique\nlocal ops mlc(black) mlw(vthin)\nforeach i of local l {\nlocal scat `scat' scatter `1' `2' if `3'==`i', `ops' ||\n}\n\ntw `scat', legend(order(`ord'))"
  },
  {
    "objectID": "formation/formation31.html",
    "href": "formation/formation31.html",
    "title": "Palettes de couleurs",
    "section": "",
    "text": "Lorsqu’ils sont générés, les graphiques appliquent un thème/style par défaut:"
  },
  {
    "objectID": "formation/formation31.html#principales-options-et-altération-dune-palette",
    "href": "formation/formation31.html#principales-options-et-altération-dune-palette",
    "title": "Palettes de couleurs",
    "section": "2.1 Principales options et altération d’une palette",
    "text": "2.1 Principales options et altération d’une palette\nModifier la taille de la palette: n(#)\nImportant car la réduction de la taille pour certaines palettes ne consiste pas à prendre les # premiers éléments de la palette par défaut (cf palettes hue ou viridis), mais forcer une palette non qualitative, donc plutôt séquentielle, à produire une palette réduite avec des types de couleurs contrastées plutôt qualitative.\nModifier l’intensité ou l’opacité : intensity(#), opacity(#) et ipolate(#)\n\nOn peut modifier l’intensité (saturation) ou l’opacité d’une palette avec intensity(#) ou intensity(numlist)** et opacity(#).\nOn peut créer une palette séquentielle à partir d’une couleur de départ avec intensity(#1(delta)#2).\nOn peut créer une palette divergente avec des couleurs de départ, d’arrivée et de transition avec ipolate(#).\n\nSelect – reverse - nograph\n\nOn peut sélectionner des couleurs d’une palette avec select(numlist). L’option autorise la répétition de couleurs, utile lorsque plusieurs objets graphiques partage une même couleur au sein d’un graphique (exemple nuages de point et courbes pour différentes valeurs d’une variable additionnelle : voir exemple avec grstyle).\nOn peut inverser l’ordre des couleurs de la palette: reverse.\nNe pas afficher la palette: nograph [voir utilisation de colorpalette pour générer un graphique]. Après avoir séléctionné les couleurs, à utiliser systématiquement pour charger la palette avant son utilisation dans un graphique. Cela réduit considérablement le temps d’exécution.\n\nCréation d’une palette de 4 couleurs\n\ncolorpalette plasma, n(4)\n\n\nRépétition d’une liste de couleur avec select(numlist)\n\ncolorpalette plasma,  select(1 8 15 1 8 15)\n\n\nCréation d’une palette séquentielle avec augmentation de l’intensité\nA partir de la couleur 3 (RGB= 237,121,83), création d’une palette sequentielle d’une longueur de 15, allant de “237,121,830” (proche blanc) à ”237,121,8315”.\n\ncolorpalette \"237 121 83\", intensity(0(.1)1.5)\n\n\nCréation d’une palette séquentielle avec augmentation de l’intensité\nCréation d’une palette séquentielle d’une longueur 15 allant de la couleur 1 à la couleur 3 de la palette plasma à 4 couleurs.\n\ncolorpalette \"13 8 135\" \"237 121 83\", ipolate(15)\n\n\nSi on ajoute la couleur 2 de la palette d’origine comme couleur de transition\n\ncolorpalette \"13 8 135\" \"156 23 158\"  \"237 121 83\", ipolate(15)\n\n\nSi on utilise le blanc comme couleur de transition, on obtient une palette divergente.\n\ncolorpalette \"13 8 135\" white \"237 121 83\", ipolate(15)\n\n\nCréer, enregistrer et charger sa propre palette\ncolorpalette permet de conserver en mémoire sa propre palette, en la générant dans un .ado (voir la fin du chapitre dédié aux macros) ou dans le programme principal. Par exemple avec la palette issue du premier exemple (palette plasma à 4 couleur).\n\n* Création de la palette mypal\ncapt program drop colorpalette_mypal\nprogram colorpalette_mypal\nc_local P 13 8 135, 156 23 158, 237 121 83, 240 249 33\nc_local class qualitative\nend\n\n* On charge la palette avec la commande colorpalette_mypal\ncolorpalette_mypal\n\n* On affiche la palette my_pal\ncolorpalette my_pal\n\n\n2.1.1 Utilisation de colorpalette pour générer un graphique\nOn remarque, avec return list, que la commande génère une liste de macros qui enregistre les codes RGB des couleurs de la palette.\n\nla macro r(p) permet d’utiliser les couleurs de la palette dans un graphique à un seul bloc d’éléments.\nles macros r(p#) permettent d’utiliser les couleurs dans un graphique composé de plusieurs éléments.\n\nLa commande colorpalette n’est qu’un générateur de couleurs qui renvoie une liste de codes RGB sous forme de macros. Si pour des graphiques simples la technique du « copié/collé » de codes RGB reste possible, l’utilisation des macros va être une nouvelle fois fortement recommandée. On peut déjà néanmoins indiquer qu’avec le générateur de thème **grstyle (voir la section suivante), également programmé par B.Jann, une sélection de couleurs pourra être directement intégrée à un graphique sans manipulation supplémentaire.\nMacros générées par colorpalette\nOn va partir de la palette plasma précédente avec 4 couleurs et un % d’opacité de 80%. Avec return list, on affiche sous forme de macros la liste des codes RGB des couleurs\n\ncolorpalette plasma, n(4) opacity(80) nograph\nreturn list\n\n/*\nscalars:\n                  r(n) =  4\n\nmacros:\n            r(ptype) : \"color\"\n            r(pname) : \"plasma\"\n            r(pnote) : \"plasma colormap from matplotlib.org\"\n            r(psource) : \"https://github.com/matplotlib/matplotlib/blob/master/lib/matplotlib/_cm_listed.py\"\n        r(pclass) : \"sequential\"\n        r(p) : \"\"13 8 135%80\" \"156 23 158%80\" \"237 121 83%80\" \"240 249 33%80\"\"\n                 r(p4) : \"240 249 33%80\"\n                 r(p3) : \"237 121 83%80\"\n                 r(p2) : \"156 23 158%80\"\n                 r(p1) : \"13 8 135%80\"\n*/\n\nLa liste renvoie la macro r(p) qui liste l’ensemble des codes couleurs. Cette macro est utilisée pour les graphiques avec un seul objet qui liste pour l’axe des ordonnées une série de variables.\nExemple\n\nsysuse uslifeexp\ncolorpalette plasma, n(4) opacity(80) nograph\ntw line le_wmale le_wfemale le_bmale le_bfemale year, lc(`r(p)')\n\nLa macro r(p) a déjà deux doubles quotes, on ne doit pas enfermer cette liste par ““.\nLa liste de macros r(p#) renvoie le code couleur de chaque élément de la palette, ici r(p1) à r(p4). Ces macros sont utilisées pour les graphiques composés de plusieurs objets. Entrée directement dans la syntaxe d’un graphique, ces macros devront être enfermées dans des doubles quotes.\nExemple\nOn va afficher un graphique avec 4 densités sous forme d’aires générées aléatoirement. De nouveau on utilisera la palette plasma réduite à 4 couleurs et 80% d’opacité.\nDonnées\n\nclear\nset obs 1000\n\ngen y1= rnormal(0,1.5)\ngen y2= rnormal(3, 2)\ngen y3= rnormal(6, 3)\ngen y4= rnormal(9, 4)\n\nforv i=1/4 {\nkdensity y`i', n(500) gen(x`i' d`i') nograph\n}\n\nGraphique (sans macros empilées pour faciliter la lisibilité du programme)\n\nColorpalette plasma , n(4) opacity(80) nograph\n\nlocal ops lc(black) lw(*.5)\n\n#delimit ;\ntw line d1 x1,  recast(area) `ops' fc(\"`r(p1)'\")  \n|| line d2 x2,  recast(area) `ops' fc(\"`r(p2)'\")\n|| line d3 x3,  recast(area) `ops' fc(\"`r(p3)'\") \n|| line d4 x4,  recast(area) `ops' fc(\"`r(p4)'\")\n\n||, legend(order(1 \"r(p1)\" 2 \"r(p2)\" 3 \"r(p3)\" 4 \"r(p4)\") pos(11) row(1) region(color(%0))) \n;\n\n\nSans modifier la syntaxe du graphique, on peut alors simplement changer de palette, en modifiant son nom et/ou en modifiant une ou plusieurs options comme l’opacité.\nExemple: palette winter de la collection matplotlib, avec 50% d’opacité et en inversant l’ordre des couleurs.\n\ncolorpalette plasma , n(4) opacity(80) nograph\n\nlocal ops lc(black) lw(*.5)\n\n#delimit ;\ntw line d1 x1,  recast(area) `ops' fc(\"`r(p1)'\")  \n|| line d2 x2,  recast(area) `ops' fc(\"`r(p2)'\")\n|| line d3 x3,  recast(area) `ops' fc(\"`r(p3)'\") \n|| line d4 x4,  recast(area) `ops' fc(\"`r(p4)'\")\n\n||, legend(order(1 \"`r(p1)'\" 2 \"`r(p2)'\" 3 \"`r(p3)'\" 4 \"`r(p4)'\") \n    pos(11) row(1) region(color(%0))) \n;\n\nRemarque : en utilisant les macros dans la légende, on a affiché les codes couleurs"
  },
  {
    "objectID": "formation/formation31.html#palettes-qualitatives",
    "href": "formation/formation31.html#palettes-qualitatives",
    "title": "Palettes de couleurs",
    "section": "3.1 Palettes qualitatives",
    "text": "3.1 Palettes qualitatives\nTableau\nhttps://www.tableau.com/about/blog/2016/7/colors-upgrade-tableau-10-56782\n\nHUE\n\nIl s’agit de la palette par défaut de ggplot2 (R)\nDe plus en plus remplacée par la palette Viridis (voir plus loin)"
  },
  {
    "objectID": "formation/formation31.html#palettes-séquentielles",
    "href": "formation/formation31.html#palettes-séquentielles",
    "title": "Palettes de couleurs",
    "section": "3.2 Palettes séquentielles",
    "text": "3.2 Palettes séquentielles\n\nUtilisées massivement en cartographie et plus généralement pour représenter des fréquences (graphique type barre) ou des valeurs ordonnées\nCouleurs allant du plus clair au plus foncé (ou inversement). – Modification de l’intensité d’une couleur. – Une ou plusieurs gammes de couleurs : par exemples du jaune au rouge, du jaune au bleu…\n\nEn réduisant la taille de certaines palettes séquentielles ou divergentes, on peut obtenir une palette plutôt qualitative. C’est le cas de la collection, très en vogue, Viridis.\nCollection viridis\n\nLa palette Viridis et les ses palettes associées (plasma, magma, cividis…) est la palette “star” du moment.\nDéveloppée pour Python pour donner une palette alternative à Matplotlib, elle est devenue la palette par défaut de la librairie graphique\nAvantages:\n\nMême rendu, ou très proche, des couleurs sur toutes les parties d’un écran (uniformité).\nDifférences de couleurs maintenue à l’impression n&b.\nGère la plupart des formes de daltonisme.\n\n\nLimites : pour les courbes, un fond blanc ou très clair ou un fond noir ou très foncé, les couleurs aux extrémités passent difficilement. Prévoir un fond gris moyen ou ne pas sélectionner les couleurs aux extrémités de la palette.\nLes autres palettes : plasma est également très utilisée, en particulier pour le remplissage de surface (aire).\nPlus d’infos : https://rtask.thinkr.fr/fr/ggplot2-welcome-viridis/\n\n\n\nCollection colorbrewer\nTrès populaire en cartographie: https://colorbrewer2.org/#type=sequential&scheme=BuGn&n=3\n\nOn présentera enfin une seule palette de type divergente, issue de cette collection, la palette spectral."
  },
  {
    "objectID": "formation/formation32.html",
    "href": "formation/formation32.html",
    "title": "Styles-thèmes",
    "section": "",
    "text": "Le thème est la « mise page » par défaut du graphique.\n\nTous les graphiques ont un thème, appelé scheme qui paramètre tous les éléments composant le graphique : couleurs, épaisseurs, positions, contours, marges….\nLes options entrées dans le graphique visent à modifier ce paramétrage.\nStata dispose de 11 thèmes internes, celui utilisé par défaut est s2color (factory scheme)\nSans modifier des options, un thème peut ne pas être adapté à un graphique.\n\nChangement de thème:\n\nPar les boîtes de dialogue: « Edit » => « Préférences » => « Graph preferences ».\nPar une ligne de commande:\n\nOn peut changer de thème en option d’un graphique : scheme(nom_scheme)\nDans un fichier .do ou .ado on peut charger un thème de façon temporaire (session) ou permanente: set scheme nom_scheme [,permanently]\nLe choix du thème peut-être également intégré au fichier profile.do (charge le thème au début de chaque session\n\n\n\n\n1 Styles internes-externes\nStyles internes\nStata fournit 11 thèmes internes dont la liste peut être obtenue avec help scheme.\nExemple de mise en page interne avec 4 de ces 11 thèmes\n\nStyles externes\nPlusieurs thèmes et collection de thèmes externe peuvent être installées, comme les collections de F.Briatte (Burd) et de D.Bischoff (plottig, plotplainblind…). Récemment A.Naqvi a programmé une série de thèmes intéressante, nommée schemepack, qui proposent pour plusieurs palettes de couleurs 3 variations : white_nompalette, black_nompalette et gg_nompalette.\nInstallation (version la plus récente)\n\nnet install schemepack,  from(\"https://raw.githubusercontent.com/asjadnaqvi/Stata-schemes/main/schemes/\") replace\n\nhelp schemepack \n\nAttention seulement une palette est de type qualitative (tableau), les autres séquentielles. L’utilisation des thèmes associés aux palettes séquentielles peuvent donner un rendu peu satisfaisant lorsque le nombre d’objets graphique réduit (par exemple 2 courbes). Il conviendra alors d’utiliser en amont colorpalette. Egalement, la position par défaut de la légende a été fixée à 3 heures ce qui n’est peut-être pas le plus judicieux.\nExemple avec les thèmes white_tableau et white_viridis \nLes deux couleurs se distinguent difficilement avec la palette viridis. On peut corriger rapidement ce problème avec colorpalette.\n\nuse uslifeexp, clear\ncolorpalette viridis, n(2) nograph\ntw line le_wfemale le_wmale year, ///\nfc(`r(p)') lc(`r(p)')  recast(area) scheme(white_viridis)\n\n\n\n\n\n2 grstyle de B.Jann\nParallèllement à colorpalette, B.Jann a mis à disposition un générateur de thème dont l’utilisation, à minima, me semble particulièrement efficace. Ici nous présenteront que les quelques options que j’utilise quasi exclusivement.\nInstallation\n\nssc install grstyle\n\nInitialisation et chargement\n\nDans un programme on initialise le générateur avec grstyle init\nOn peut enregistrer un thème avec un nom: grstyle init nom_thème, [path] [replace]\nSi le thème a été enregistré, on peut le charger dans un graphique avec scheme(nom_scheme) ou avec la commande set scheme. Lors de sa création, le thème est chargé pendant la session.\nLes modifications de l’habillage et de la mise en page du graphique se fait avec une série de commandes préfixées par grstyle set [legend/color….].\n\nBackground du graphique, grid, légende\ngrstyle propose 3 options pour le background et le quadrillage : plain, mesh et imesh. Par exemples avec quelques sous options supplémentaires:\n\ngrstyle set plain, horizontal compact\ngrstyle set mesh,  horizontal compact\ngrstyle set imesh, horizontal compact\n\nLégende ( position et retirer le contour)\nOn peut retirer facilement le contour de la légende (on allège ainsi les options du graphique) avec nobox. En positionnant la légende à 11 heures\n\ngrstyle set legend 11 , nobox\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCouleurs\nMême syntaxe que colorpalette, ici on associe le choix de la palette de couleurs à grstyle set color Avec la palette viridis réduite à deux couleurs, par exemple avec select(1 11)\n\ngrstyle set color viridis, select(1 11)\n\nExemple avec le fond de type mesh, la légende à 11 heures sans contour et une sélection de deux couleurs de la palette viridis\n\n\nwebuse set https://github.com/mthevenin/stata_graphiques/tree/main/bases\nuse pingouin, replace\nwebuse set\n\ngrstyle init\ngrstyle set mesh, horizontal compact \ngrstyle set legend 11, nobox \ngrstyle set color plasma, select(6 9 12 6 9 12)\n\nlocal osl  lw(*1.2)\nlocal osca   msize(*.8) msymbol(+)  \n\n#delimit ;\ntw sca    bill_length_mm  flipper_length_mm if espèce==1,  jitter(3) `osca'           \n|| sca    bill_length_mm  flipper_length_mm if espèce==2,  jitter(3) `osca' \n|| sca    bill_length_mm  flipper_length_mm if espèce==3,  jitter(3) `osca' \n|| lowess bill_length_mm  flipper_length_mm if espèce==1,   `osl'        \n|| lowess bill_length_mm  flipper_length_mm if espèce==2,   `osl'  \n|| lowess bill_length_mm  flipper_length_mm if espèce==3, `osl'                          \n      \n|| , legend(order(1 \"Pingouin Adélie\" 2 \"Manchot à jugulaire\" 3 \"Manchot papou\") row(1))\n     ytitle(\"Longueur bec (mm)\") xtitle(\"Longueur nageoire (mm)\")\n     title(\"Longueurs du bec et des nageoires\")\n;\n\n#delimit cr\n\nPlus qu’un générateur de thème, une utilisation minimale grstyle permet de paramétrer des options en amont du graphique et donc d’alleger sensiblement son programme et faciliter ses modifications."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Graphiques",
    "section": "",
    "text": "Mise à jour de la formation\n\n\n\n\nChapitres 1 à 3 en ligne.\nLien vers le nouveau support de formation en format pdf [chapitre 1 à 3]: \nChapitre 4: la structure de ce chapitre de la première version ne me convient pas. On retrouve déjà un certain nombre d’éléments dans la partie ressources graphiques.\n\n\n\n\n\n\n\n\n\nRessources graphiques\n\n\n\n\nTopics sur la programmation de graphiques avec le langage Stata\nPrésentation de la programmation de graphiques avec Python sous Stata [A ajouter rapidement]\n\n\n\n\n\n Support réalisé avec Rstudio - Quarto.\n Version Stata: 17-SE"
  },
  {
    "objectID": "programmation/fabplot/fabplot.html",
    "href": "programmation/fabplot/fabplot.html",
    "title": "fabplot (NJ.Cox)",
    "section": "",
    "text": "La commande fabplot programmée en 2021 par Nj.Cox permet de contrôler efficacement les effets dits spaghetti (courbes) ou paella (nuages de points). J’ai ajouté une option pour modifier les courbes au second plan, NJ.Cox ayant toujours tendance à bloquer l’habillage de ces commandes graphiques. La commande a été renommée fabplot2 et s’installe via github.\nArticle Stata Journal\nJ’avais présenté le problème lors de la formation de 2020, mais avec un programme très compliqué. Cette commande très simple, permet de bien contrôler ce problème visualisation en utilisant sur deux objets graphiques l’option by…..pourquoi je n’y avais pas pensé."
  },
  {
    "objectID": "programmation/fabplot/fabplot.html#fabplot",
    "href": "programmation/fabplot/fabplot.html#fabplot",
    "title": "fabplot (NJ.Cox)",
    "section": "1.1 fabplot",
    "text": "1.1 fabplot\nCommande d’origine. L’objet en arrière plan n’est pas modifiable.\n\nssc install fabplot\n\n* help fabplot"
  },
  {
    "objectID": "programmation/fabplot/fabplot.html#fabplot2",
    "href": "programmation/fabplot/fabplot.html#fabplot2",
    "title": "fabplot (NJ.Cox)",
    "section": "1.2 fabplot2",
    "text": "1.2 fabplot2\nJ’ai juste ajouté l’option backopts. Même principe que l’option frontopts qui modifie l’objet au premier plan.\n\nnet install fabplot2, from(\"https://mthevenin.github.io/stata_graphiques/ressources/fabplot/\") replace"
  },
  {
    "objectID": "programmation/fabplot/fabplot.html#exemple",
    "href": "programmation/fabplot/fabplot.html#exemple",
    "title": "fabplot (NJ.Cox)",
    "section": "1.3 Exemple",
    "text": "1.3 Exemple\n\nNote J’utilise systématiquement un thème que je génère avec le paquet grstyle de B.Jann.\n\nJe reprends le même exemple que pour la formation, avec la base babynames.\nOuverture de de la base:\n\nwebuse set \"https://raw.githubusercontent.com//mthevenin/stata_graphiques/master/ressources/fabplot\"\nuse babynames, clear\nwebuse set\n\n\n1.3.1 Empilement des 9 courbes\n….. C’est illisible\n\n* thème avec grstyle\ngrstyle init \ngrstyle set mesh\ngrstyle set color tableau, n(9)\n\n* Graphique\nlevelsof name, local(name)\nlocal i = 1\nforeach nom of local name  {\nlocal j = `i++' \nlocal line `line' line n year if name==\"`nom'\" ||       \nlocal leg `leg'  `j' \"`nom'\"\n}\n\ntw `line' , legend(order(`leg') row(2) size(*.8)  region(color(%0)) pos(11)) ytitle(\"\") ylabel(0(20000)100000, angle(0)) ///\ntitle(\"Popularité des prénoms\")"
  },
  {
    "objectID": "programmation/fabplot/fabplot.html#syntaxe-allégée",
    "href": "programmation/fabplot/fabplot.html#syntaxe-allégée",
    "title": "fabplot (NJ.Cox)",
    "section": "2.1 Syntaxe allégée",
    "text": "2.1 Syntaxe allégée\nfabplot[2] command yvar xvar [if] [in], by(byvar [,byopts]) [frontopts() backopts()] ....\n\nfabplot[2]: fabplot ou fabplot2\ncommand: line ou scatter\nby(byvar [,opts)]: indiquer à minima la variable catégorielle qui produira chaque sous graphique. Beaucoup d’options du graphique entre sans cette option, comme les titres ou la couleur du background\nfrontopts: les options de l’objet graphique en relief, comme la couleur et l’épaisseur de la courbe ou des marqueurs\nbackopts: avec fabplot2 seulement, les options de l’objet graphique en arrière plan."
  },
  {
    "objectID": "programmation/fabplot/fabplot.html#application",
    "href": "programmation/fabplot/fabplot.html#application",
    "title": "fabplot (NJ.Cox)",
    "section": "2.2 Application",
    "text": "2.2 Application\n\n#delimit ;\n\nfabplot2 line n year, \nby(name, title(\"Popularité des prénoms\", pos(11))) \n\nfrontopts(lw(*2) lc(\"45 178 125\")) \nbackopts(lw(*.5) lc(gs9)) \n\nytitle(\"\")  ylabel(0(20000)100000, labsize(*.8) glw(*.5))\n; \n\n#delimit cr\n\n\nProgramme .do"
  },
  {
    "objectID": "programmation/gjoint/gjoint.html",
    "href": "programmation/gjoint/gjoint.html",
    "title": "gjoint",
    "section": "",
    "text": "Petite commande graphique en version alpha: gjoint. Permet de visualiser la distribution croisée de deux variables quantitatives avec la commande hexplot de Ben Jann, en reportant également les distributions marginales avec des d’histogrammes.\nPas de gros changement à prévoir, si ce n’est ajouter la possibilité de sélectionner des observations avec [if/else].\n\nExemple\n*Installation: pour l’instant manuellement. Récupérer le programme gjoint.ado à cette adresse: (https://github.com/mthevenin/stata_graphiques/blob/main/ressources/gjoint/gjoint.ado), l’exécuter dans l’éditeur de programme ou le sauvegarder dans un sous répertoire de l’ado plus\nOuverture de la base\n\nwebuse set  \"https://raw.githubusercontent.com//mthevenin/stata_graphiques/master/ressources/gjoint\"\nwebuse \"logement.dta\", clear\nwebuse set\n\nExécution du graphique\n\ngjoint prix surface,  hopts(levels(10) fast) palette(flare, reverse) title(\"gjoint alpha\")\n\nRemarque: le temps d’exécution est de 6-7 secondes pour l’exemple (Stata 17 Se)"
  },
  {
    "objectID": "programmation/gridge/gridge.html",
    "href": "programmation/gridge/gridge.html",
    "title": "gridge",
    "section": "",
    "text": "Depuis 2020, des programmes permettent de générer de type lignes de crête: joyplot (A.Naqvi) et joy_plot (F.Rios-Avila).\nLa première commande, malgré une maj récente, présente toujours des problèmes concernant le report des informations sur l’axe discret pour la version joyplot y.\nA partir d’un programme écrit à l’automne 2020, et en restant au plus près de la fonction ggridge de R, j’ai également programmé une commande. Elle permet, entre autres, de paramétrer le tri les modalités de l’axe discret à partir d’une fonction autorisée avec egen (mean, median, sd….), de choisir librement un intervalle sur l’axe des abcisses pour éviter le report de valeurs sortant de borne acceptables (probabilité négatives ou supérieure à 1 par exemple). Comme on estime des densités, le nombre d’observations minimales a été fixé à 10. Si ce critère n’est pas respecté, les valeurs de y qui ne respectent pas cette contrainte sont affichées.\nDes améliorations restent néanmoins à prévoir."
  },
  {
    "objectID": "programmation/gridge/gridge.html#installation",
    "href": "programmation/gridge/gridge.html#installation",
    "title": "gridge",
    "section": "0.1 Installation",
    "text": "0.1 Installation\n\nnet install gridge, from(\"https://mthevenin.github.io/stata_graphiques/ressources/gridge/\") replace"
  },
  {
    "objectID": "programmation/lollipop/lollipop.html",
    "href": "programmation/lollipop/lollipop.html",
    "title": "Lollipop",
    "section": "",
    "text": "Lolliplot et haltère: pourquoi faire compliquer lorsque…..\nJ’étais complétement passé à côte de la fonction axis du package egenmore de Nj.Cox. Elle permet de construire un axe discret ordonné en récupérant automatiquement les labels d’une variable. Les programmes de la version 2000 pour générer des graphiques de types lollipop ou haltères, qui étaient particulièrement complexes et long se retouvent, et pas qu’un peu, extrêmement simplifiés:\n\n\n* ssc install egenmore\n\nsysuse nlsw88, clear\ndrop if inlist(occupation,9,10,12) \n\negen mwage = mean(wage), by(occupation)\negen occ   = axis(mwage occupation) , label(occupation)\n\ntwoway scatter occ mwage ///\n|| dropline mwage occ, horizontal ///\n|| , ylab(1/10, valuelabel angle(0)) legend(off) \n\ndrop mwage occ // utiliser des variables temporaires si possible\n\nCommande axis (NJ.Cox)\n\nComme la fonction group (egen), elle va créer une variable ordinale occ à partir des valeurs prises par une variable, ici mwage.\nElle va affecter les labels de la variable occupation à la variable ordinale.\n\nJ’en ai profité pour découvrir l’option labelvalue de x/ylabel() qui permet d’affecter directement les labels d’une variable catégorielle sur un axe [A documenter dans la formation].\nSi on souhaite mettre comme valeur de base la moyenne des salaires moyens selon le groupe professionnel, on utilise simple l’option base() à laquelle on affecte la valeur moyenne des salaires récupérée en amont dans une macro:\n\n\nqui sum mwage, d\nlocal b = `r(mean)'\ntw dropline mwage occ, horizontal mlc(black) mlw(*.2) base(`b')  ///\n|| , ylab(1/10, valuelabel angle(0)) legend(off)                 ///\nxline(`b', noext lc(black)) title(\"Lollipop\", pos(11))           ///\nxtitle(\"Salaire moyen\") ytitle(\"Emploi\")\n\n[A venir]: les graphiques de type haltère. Il faudra passer par un collapse, mais le gain en terme de programmation est également non négligeable."
  },
  {
    "objectID": "Stata.html",
    "href": "Stata.html",
    "title": "Graphiques Stata",
    "section": "",
    "text": "Vous trouverez ici des topics concernant la programmation de graphiques avec Stata, et seront inclus au quatrième chapitre de la formation. Ce document sera peut-être réogarnisé savec l’évolution de son contenu. \n\n\n\n\n  \n\n\n\n\nLollipop\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\nfabplot (NJ.Cox)\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\ngjoint\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\n  \n\n\n\n\ngridge\n\n\n\n\n\n\n\n\n\n\n \n\n\n\n\nNo matching items"
  }
]